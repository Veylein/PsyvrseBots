# Combined villicus bot files

# Generated by tools/build_combined_bot.py


import sys
import types
from types import ModuleType

# Ensure repo root is on sys.path for relative imports

import os
ROOT = os.path.dirname(__file__)
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

from villicus.core import constants

# Shim: allow imports that expect a top-level `core` package to resolve
try:
    import core  # type: ignore
except Exception:
    try:
        import importlib
        core = importlib.import_module('villicus.core')
        import sys as _sys
        _sys.modules['core'] = core
    except Exception:
        pass



    # Register embedded `villicus.bot.*` module names so relative imports inside
    # the combined bundle resolve to placeholders (the code for each submodule
    # is present later in this file). This allows statements like
    # `from .mod_manager import ModManager` to succeed during import.
    try:
        import re
        from types import ModuleType as _ModuleType
        src = open(__file__, 'r', encoding='utf-8').read()
        names = re.findall(r"# ---- FILE: .*bot[\\/](?P<name>[\w_]+)\\.py ----", src)
        # ensure package modules exist
        sys.modules.setdefault('villicus', _ModuleType('villicus'))
        sys.modules.setdefault('villicus.bot', _ModuleType('villicus.bot'))
        for nm in names:
            modname = f"villicus.bot.{nm}"
            if modname not in sys.modules:
                # register a placeholder module object; actual attributes will be
                # populated when the later code in this file executes.
                sys.modules[modname] = _ModuleType(modname)
    except Exception:
        pass

    # ---- FILE: villicus\bot\__init__.py ----

# bot/__init__.py

try:
    from                        villicus.bot.bot import start_bot
except Exception:
    # In combined bundle the original package structure may not be importable.
    # Provide a fallback that raises if called.
    def start_bot(*args, **kwargs):
        raise RuntimeError('start_bot is not available in the combined bundle')




# ---- FILE: villicus\bot\actionlog_cog.py ----

# bot/actionlog_cog.py
import discord
from discord.ext import commands
from discord import ui
from core import ui as core_ui
from datetime import datetime
import asyncio


class ActionLogCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.log_channels = {}  # {guild_id: channel_id}
        self.log_types = {}  # {guild_id: set(types)}

    @commands.hybrid_command(name="log", description="Set the logging channel and log type.")
    @commands.has_guild_permissions(administrator=True)
    async def log(self, ctx, channel: discord.TextChannel, log_type: str = "all"):
        guild_id = ctx.guild.id
        self.log_channels[guild_id] = channel.id
        if log_type == "all":
            self.log_types[guild_id] = {"ban", "kick", "mute", "unmute", "edit", "delete", "server", "warn", "tempban"}
        else:
            self.log_types.setdefault(guild_id, set()).add(log_type)
        await ctx.send(f"Logging set to {channel.mention} for {log_type} events.")

    async def send_log(self, guild_id, embed: discord.Embed):
        channel_id = self.log_channels.get(guild_id)
        if channel_id:
            channel = self.bot.get_channel(channel_id)
            if channel:
                await channel.send(embed=embed)

    async def send_action_log(self, guild_id: int, action: str, user_display: str, moderator_display: str | None = None,
                              reason: str | None = None, duration: str | None = None, thumbnail: str | None = None):
        # Build pretty embed using core UI
        embed = core_ui.moderation_embed(action, user_display, moderator_display, reason, duration, thumbnail)
        # Attach interactive buttons for moderation actions so staff can undo or take follow-up actions
        view = None
        try:
            view = self._build_action_view(guild_id, action, user_display)
        except Exception:
            view = None
        await self.send_log(guild_id, embed, view=view)

    def _build_action_view(self, guild_id: int, action: str, user_display: str):
        class ActionView(ui.View):
            def __init__(self, bot, guild_id, action, target):
                super().__init__(timeout=None)
                self.bot = bot
                self.guild_id = guild_id
                self.action = action
                self.target = target

            async def _has_permission(self, interaction: discord.Interaction) -> bool:
                # Allow guild managers or configured staff (via ModManager)
                try:
                    if interaction.user.guild_permissions.manage_guild:
                        return True
                except Exception:
                    pass
                try:
                    mod_cog = self.bot.get_cog("ModCommandsCog")
                    if mod_cog and hasattr(mod_cog, 'mod_manager') and mod_cog.mod_manager:
                        lvl = await mod_cog.mod_manager.get_member_staff_level(interaction.guild.id, interaction.user)
                        return lvl >= 3
                except Exception:
                    pass
                return False

            @ui.button(label="Undo", style=discord.ButtonStyle.danger)
            async def undo(self, interaction: discord.Interaction, button: ui.Button):
                if not await self._has_permission(interaction):
                    await interaction.response.send_message("You don't have permission to use this.", ephemeral=True)
                    return
                await interaction.response.defer()
                # Attempt to reverse the action
                guild = interaction.guild
                if not guild:
                    await interaction.followup.send("Guild not available.", ephemeral=True)
                    return
                # Parse user id from target if possible (format: Name (id))
                target_id = None
                try:
                    if '(' in self.target and self.target.strip().endswith(')'):
                        target_id = int(self.target.split('(')[-1].strip(')'))
                except Exception:
                    target_id = None
                result = False
                try:
                    if self.action in ("ban", "tempban", "softban"):
                        if target_id:
                            try:
                                user = await self.bot.fetch_user(target_id)
                                await guild.unban(user)
                                result = True
                            except Exception:
                                result = False
                    elif self.action == "mute":
                        if target_id:
                            member = guild.get_member(target_id)
                            if member:
                                try:
                                    await member.edit(timeout=None)
                                    result = True
                                except Exception:
                                    result = False
                    elif self.action == "kick":
                        # Kick cannot be undone, but we can note it
                        result = False
                except Exception:
                    result = False

                # Update DB to remove persistent punishments if applicable
                try:
                    mod_cog = self.bot.get_cog("ModCommandsCog")
                    if mod_cog and hasattr(mod_cog, 'mod_manager') and mod_cog.mod_manager and target_id:
                        await mod_cog.mod_manager.remove_punishments_for(guild.id, target_id, actions=[self.action])
                except Exception:
                    pass

                for child in self.children:
                    child.disabled = True
                if result:
                    await interaction.followup.send(f"Reversed {self.action} for {self.target}.")
                    await interaction.message.edit(view=self)
                else:
                    await interaction.followup.send(f"Could not reverse {self.action} for {self.target}.", ephemeral=True)

            @ui.button(label="Appeal", style=discord.ButtonStyle.secondary)
            async def appeal(self, interaction: discord.Interaction, button: ui.Button):
                await interaction.response.defer(ephemeral=True)
                gid = interaction.guild.id if interaction.guild else guild_id
                appeal_type = None
                appeal_value = None
                try:
                    config = self.bot.get_cog('ConfigCog')
                    if config and getattr(config, 'mod_manager', None):
                        appeal_type = await config.mod_manager.get_guild_setting(gid, 'appeal_type')
                        appeal_value = await config.mod_manager.get_guild_setting(gid, 'appeal_value')
                    else:
                        appeals = self.bot.get_cog('AppealsCog')
                        if appeals and hasattr(appeals, 'appeal_url'):
                            appeal_type = 'url'
                            appeal_value = appeals.appeal_url
                except Exception:
                    pass
                if appeal_type in ('url', 'invite') and appeal_value:
                    try:
                        await interaction.user.send(f"You may appeal here: {appeal_value}")
                        await interaction.followup.send('Appeal instructions sent via DM.', ephemeral=True)
                    except Exception:
                        await interaction.followup.send(f"Could not DM you. Appeal here: {appeal_value}", ephemeral=True)
                else:
                    await interaction.followup.send('No appeal configured for this server.', ephemeral=True)

        return ActionView(self.bot, guild_id, action, user_display)

    @commands.Cog.listener()
    async def on_member_ban(self, guild, user):
        if "ban" in self.log_types.get(guild.id, set()):
            await self.send_action_log(guild.id, "ban", str(user))

    @commands.Cog.listener()
    async def on_member_unban(self, guild, user):
        if "unban" in self.log_types.get(guild.id, set()):
            await self.send_action_log(guild.id, "unban", str(user))

    @commands.Cog.listener()
    async def on_member_remove(self, member):
        if "kick" in self.log_types.get(member.guild.id, set()):
            await self.send_action_log(member.guild.id, "kick", str(member))

    @commands.Cog.listener()
    async def on_message_delete(self, message):
        if message.guild and "delete" in self.log_types.get(message.guild.id, set()):
            desc = f"{message.author}: {message.content}" if message.content else f"Message deleted by {message.author}"
            embed = discord.Embed(title="Message Deleted", description=desc, color=discord.Color.red())
            await self.send_log(message.guild.id, embed)

    @commands.Cog.listener()
    async def on_message_edit(self, before, after):
        if before.guild and "edit" in self.log_types.get(before.guild.id, set()):
            embed = discord.Embed(title="Message Edited", description=f"{before.author}\nBefore: {before.content}\nAfter: {after.content}", color=discord.Color.blue())
            await self.send_log(before.guild.id, embed)

    @commands.Cog.listener()
    async def on_guild_update(self, before, after):
        if "server" in self.log_types.get(before.id, set()):
            embed = discord.Embed(title="Server Updated", description=f"Server settings changed.", color=discord.Color.purple())
            await self.send_log(before.id, embed)


def setup(bot):
    bot.add_cog(ActionLogCog(bot))




# ---- FILE: villicus\bot\afk_cog.py ----

# bot/afk_cog.py
import discord
from discord.ext import commands
import datetime

class AFKCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.afk = {}  # {guild_id: {user_id: (reason, timestamp)}}

    @commands.hybrid_command(name="afk", description="Set your AFK status.")
    async def afk(self, ctx, *, reason: str = "AFK"):
        guild_id = ctx.guild.id
        user_id = ctx.author.id
        self.afk.setdefault(guild_id, {})[user_id] = (reason, datetime.datetime.utcnow())
        await ctx.send(f"{ctx.author.mention} is now AFK: {reason}")

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot or not message.guild:
            return
        guild_id = message.guild.id
        user_id = message.author.id
        # Remove AFK if user sends a message
        if user_id in self.afk.get(guild_id, {}):
            del self.afk[guild_id][user_id]
            await message.channel.send(f"{message.author.mention} is no longer AFK.")
        # Notify if mentioning AFK users
        if message.mentions:
            for member in message.mentions:
                afk_data = self.afk.get(guild_id, {}).get(member.id)
                if afk_data:
                    reason, since = afk_data
                    ago = (datetime.datetime.utcnow() - since).seconds // 60
                    await message.channel.send(f"{member.display_name} is AFK: {reason} (for {ago} min)")

def setup(bot):
    bot.add_cog(AFKCog(bot))




# ---- FILE: villicus\bot\antinuke_cog.py ----

# bot/antinuke_cog.py
import discord
from discord.ext import commands
import asyncio

class AntiNukeCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.enabled = {}  # {guild_id: bool}
        self.raid_threshold = {}  # {guild_id: int}
        self.spam_threshold = {}  # {guild_id: int}
        self.join_times = {}  # {guild_id: [timestamps]}
        self.message_counts = {}  # {guild_id: {user_id: [timestamps]}}

    @commands.hybrid_command(name="antinuke", description="Enable or disable anti-nuke/anti-raid/anti-spam.")
    @commands.has_guild_permissions(administrator=True)
    async def antinuke(self, ctx, action: str, raid: int = 5, spam: int = 10):
        guild_id = ctx.guild.id
        if action == "enable":
            self.enabled[guild_id] = True
            self.raid_threshold[guild_id] = raid
            self.spam_threshold[guild_id] = spam
            await ctx.send(f"Anti-nuke enabled. Raid: {raid}/10s, Spam: {spam}/10s")
        elif action == "disable":
            self.enabled[guild_id] = False
            await ctx.send("Anti-nuke disabled.")
        else:
            await ctx.send("Usage: antinuke <enable/disable> [raid threshold] [spam threshold]")

    @commands.Cog.listener()
    async def on_member_join(self, member):
        guild_id = member.guild.id
        if not self.enabled.get(guild_id, False):
            return
        now = discord.utils.utcnow().timestamp()
        self.join_times.setdefault(guild_id, []).append(now)
        # Remove old
        self.join_times[guild_id] = [t for t in self.join_times[guild_id] if now - t < 10]
        if len(self.join_times[guild_id]) >= self.raid_threshold.get(guild_id, 5):
            # Raid detected
            for m in member.guild.members:
                if not m.bot:
                    try:
                        # record an explainable auto-action and attempt to kick
                        modc = self.bot.get_cog('ModCommandsCog')
                        mm = getattr(modc, 'mod_manager', None) if modc else None
                        if mm:
                            await mm.record_decision(member.guild.id, m.id, 'kick', reason='Anti-raid: mass join detected', moderator_id=None, metadata={'auto_applied': True, 'source': 'antinuke'})
                        try:
                            await m.kick(reason="Anti-raid: mass join detected")
                        except Exception:
                            pass
                    except Exception:
                        pass
            self.join_times[guild_id] = []

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot or not message.guild:
            return
        guild_id = message.guild.id
        if not self.enabled.get(guild_id, False):
            return
        now = discord.utils.utcnow().timestamp()
        self.message_counts.setdefault(guild_id, {}).setdefault(message.author.id, []).append(now)
        # Remove old
        self.message_counts[guild_id][message.author.id] = [t for t in self.message_counts[guild_id][message.author.id] if now - t < 10]
        if len(self.message_counts[guild_id][message.author.id]) >= self.spam_threshold.get(guild_id, 10):
            try:
                modc = self.bot.get_cog('ModCommandsCog')
                mm = getattr(modc, 'mod_manager', None) if modc else None
                if mm:
                    await mm.record_decision(message.guild.id, message.author.id, 'kick', reason='Anti-spam: message flood detected', moderator_id=None, metadata={'auto_applied': True, 'source': 'antinuke'})
                try:
                    await message.author.kick(reason="Anti-spam: message flood detected")
                except Exception:
                    pass
            except Exception:
                pass
            self.message_counts[guild_id][message.author.id] = []

def setup(bot):
    bot.add_cog(AntiNukeCog(bot))




# ---- FILE: villicus\bot\api_cog.py ----

import os
import asyncio
from aiohttp import web
import json
import logging
from discord.ext import commands
import httpx
import jwt
from datetime import datetime, timedelta

log = logging.getLogger("bot_api")

API_KEY = os.getenv("BOT_API_KEY")
API_PORT = int(os.getenv("BOT_API_PORT", "5000"))
JWT_SECRET = os.getenv('BOT_JWT_SECRET', API_KEY or 'change-me')
JWT_ALGO = 'HS256'


def _check_api_key(request):
    key = request.headers.get("X-API-KEY")
    return key == API_KEY


def _check_jwt(request, require_scope=None, guild_id=None):
    auth = request.headers.get('Authorization', '')
    if not auth.startswith('Bearer '):
        return False, None
    token = auth.split(' ', 1)[1]
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGO])
    except Exception:
        return False, None
    # optional scope/guild checks
    if require_scope:
        scopes = payload.get('scopes', [])
        if require_scope not in scopes:
            return False, None
    if guild_id is not None:
        if str(payload.get('guild')) != str(guild_id):
            return False, None
    return True, payload


class BotAPICog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self._runner = None
        self._site = None
        self.app = web.Application()
        self.app.add_routes([
            web.post('/api/token', self.issue_token),
            web.get('/api/stats', self.get_stats),
            web.get('/api/guilds/{guild_id}/settings', self.get_guild_settings),
            web.get('/api/guilds/{guild_id}/roles', self.get_guild_roles),
            web.get('/api/guilds/{guild_id}/status', self.get_guild_status),
            web.get('/api/guilds/{guild_id}/logs', self.get_guild_logs),
            web.post('/api/guilds/{guild_id}/lazy_setup', self.post_lazy_setup),
            web.post('/api/guilds/{guild_id}/settings', self.post_guild_settings),
            web.post('/api/guilds/{guild_id}/staffrole', self.post_staff_role),
            web.delete('/api/guilds/{guild_id}/staffrole', self.delete_staff_role),
        ])
        loop = asyncio.get_event_loop()
        loop.create_task(self._start_server())

    async def _start_server(self):
        try:
            self._runner = web.AppRunner(self.app)
            await self._runner.setup()
            self._site = web.TCPSite(self._runner, '0.0.0.0', API_PORT)
            await self._site.start()
            log.info(f"Bot API running on port {API_PORT}")
        except Exception as e:
            log.exception("Failed to start Bot API: %s", e)

    async def cog_unload(self):
        try:
            if self._runner:
                await self._runner.cleanup()
        except Exception:
            pass

    async def _auth(self, request):
        # Allow either API key or valid JWT
        if _check_api_key(request):
            return None
        ok, payload = _check_jwt(request)
        if ok:
            # attach payload for handlers
            request['jwt_payload'] = payload
            return None
        return web.json_response({"error": "unauthorized"}, status=401)

    async def issue_token(self, request):
        # Exchange website user's OAuth access token for a short-lived JWT scoped to a guild
        # Require X-API-KEY to prevent public abuse
        if not _check_api_key(request):
            return web.json_response({"error": "unauthorized"}, status=401)
        data = await request.json()
        access_token = data.get('access_token')
        guild_id = data.get('guild_id')
        if not access_token or not guild_id:
            return web.json_response({"error": "missing access_token or guild_id"}, status=400)

        # Validate access_token by calling Discord API to check membership/permissions
        async with httpx.AsyncClient() as client:
            try:
                me = await client.get('https://discord.com/api/users/@me', headers={'Authorization': f'Bearer {access_token}'})
                me.raise_for_status()
                me_json = me.json()
            except Exception:
                return web.json_response({"error": "invalid access_token"}, status=401)

            try:
                guilds = await client.get('https://discord.com/api/users/@me/guilds', headers={'Authorization': f'Bearer {access_token}'})
                guilds.raise_for_status()
                guilds_json = guilds.json()
            except Exception:
                guilds_json = []

        # Check that the user is admin or owner in the requested guild
        allowed = False
        for g in guilds_json:
            if str(g.get('id')) == str(guild_id):
                if g.get('owner') or (g.get('permissions', 0) & 0x8):
                    allowed = True
                break
        if not allowed:
            return web.json_response({"error": "user not admin of guild"}, status=403)

        # Issue JWT
        payload = {
            'sub': me_json.get('id'),
            'guild': str(guild_id),
            'scopes': ['settings:write', 'roles:write'],
            'iat': datetime.utcnow(),
            'exp': datetime.utcnow() + timedelta(minutes=10)
        }
        token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGO)
        return web.json_response({'token': token})

    async def get_guild_settings(self, request):
        auth = await self._auth(request)
        if auth:
            return auth
        guild_id = int(request.match_info['guild_id'])
        mm = None
        try:
            modcog = self.bot.get_cog('ModCommandsCog')
            mm = modcog.mod_manager
        except Exception:
            pass
        if not mm:
            return web.json_response({"error": "ModManager not available"}, status=500)
        settings = {}
        # fetch common settings
        keys = ['warns_to_punish', 'warn_punish_action', 'warn_punish_duration']
        for k in keys:
            settings[k] = await mm.get_guild_setting(guild_id, k)
        settings['staff_roles'] = await mm.get_staff_roles(guild_id)
        return web.json_response(settings)

    async def get_stats(self, request):
        # Allow API key or internal JWT
        if not _check_api_key(request):
            ok, _ = _check_jwt(request)
            if not ok:
                return web.json_response({"error": "unauthorized"}, status=401)
        try:
            servers = len(self.bot.guilds)
        except Exception:
            servers = 0
        try:
            commands = len([c for c in self.bot.commands if not getattr(c, 'hidden', False)])
        except Exception:
            commands = 0
        # audit log count if ModManager available
        try:
            modcog = self.bot.get_cog('ModCommandsCog')
            mm = modcog.mod_manager if modcog else None
            audit_count = 0
            if mm and hasattr(mm, 'get_action_logs'):
                logs = await mm.get_action_logs()
                audit_count = len(logs)
        except Exception:
            audit_count = 0
        payload = {
            'servers_count': servers,
            'commands_count': commands,
            'audit_count': audit_count,
            'generated_at': datetime.utcnow().isoformat() + 'Z',
            'why_choose': [
                'Fast, reliable moderation tools',
                'Persistent punishments & audit logs',
                'Granular staff levels (1–10) and warns→punish automation',
            ]
        }
        return web.json_response(payload)

    async def get_guild_roles(self, request):
        auth = await self._auth(request)
        if auth:
            return auth
        guild_id = int(request.match_info['guild_id'])
        guild = self.bot.get_guild(guild_id)
        if not guild:
            try:
                guild = await self.bot.fetch_guild(guild_id)
            except Exception:
                return web.json_response({"error": "guild not found"}, status=404)
        roles = []
        try:
            for r in guild.roles:
                roles.append({
                    "id": r.id,
                    "name": r.name,
                    "color": getattr(r.color, 'value', 0) if hasattr(r, 'color') else 0,
                    "mentionable": getattr(r, 'mentionable', False)
                })
        except Exception:
            pass
        return web.json_response({"roles": roles})

    async def get_guild_status(self, request):
        auth = await self._auth(request)
        if auth:
            return auth
        guild_id = int(request.match_info['guild_id'])
        guild = self.bot.get_guild(guild_id)
        present = bool(guild)
        return web.json_response({"bot_present": present})

    async def get_guild_logs(self, request):
        auth = await self._auth(request)
        if auth:
            return auth
        guild_id = int(request.match_info['guild_id'])
        try:
            modcog = self.bot.get_cog('ModCommandsCog')
            mm = modcog.mod_manager
            logs = await mm.get_action_logs(guild_id)
            # return last 200 logs by default
            return web.json_response({"logs": logs[-200:]})
        except Exception as e:
            return web.json_response({"error": str(e)}, status=500)

    async def post_lazy_setup(self, request):
        auth = await self._auth(request)
        if auth:
            return auth
        guild_id = int(request.match_info['guild_id'])
        try:
            # Attempt to run lazy setup via ModManager if available
            modcog = self.bot.get_cog('ModCommandsCog')
            mm = modcog.mod_manager
            if hasattr(mm, 'lazy_setup'):
                res = await mm.lazy_setup(guild_id)
                return web.json_response({"ok": True, "result": res})
            else:
                # placeholder response if not implemented
                return web.json_response({"ok": False, "note": "lazy_setup not implemented on bot"}, status=501)
        except Exception as e:
            return web.json_response({"error": str(e)}, status=500)

    async def post_guild_settings(self, request):
        auth = await self._auth(request)
        if auth:
            return auth
        guild_id = int(request.match_info['guild_id'])
        data = await request.json()
        mm = None
        try:
            modcog = self.bot.get_cog('ModCommandsCog')
            mm = modcog.mod_manager
        except Exception:
            pass
        if not mm:
            return web.json_response({"error": "ModManager not available"}, status=500)
        # Accept keys and set them
        for k, v in data.items():
            await mm.set_guild_setting(guild_id, k, str(v) if v is not None else None)
        return web.json_response({"ok": True})

    async def post_staff_role(self, request):
        auth = await self._auth(request)
        if auth:
            return auth
        guild_id = int(request.match_info['guild_id'])
        data = await request.json()
        role_id = int(data.get('role_id'))
        level = int(data.get('level'))
        try:
            modcog = self.bot.get_cog('ModCommandsCog')
            mm = modcog.mod_manager
            await mm.add_staff_role(guild_id, role_id, level)
            return web.json_response({"ok": True})
        except Exception as e:
            return web.json_response({"error": str(e)}, status=500)

    async def delete_staff_role(self, request):
        auth = await self._auth(request)
        if auth:
            return auth
        guild_id = int(request.match_info['guild_id'])
        data = await request.json()
        role_id = int(data.get('role_id'))
        try:
            modcog = self.bot.get_cog('ModCommandsCog')
            mm = modcog.mod_manager
            await mm.remove_staff_role(guild_id, role_id)
            return web.json_response({"ok": True})
        except Exception as e:
            return web.json_response({"error": str(e)}, status=500)


def setup(bot):
    bot.add_cog(BotAPICog(bot))




# ---- FILE: villicus\bot\appeals_cog.py ----

import discord
from discord.ext import commands
import asyncio
import json
from core import db as core_db


class AppealActionView(discord.ui.View):
    def __init__(self, cog, guild_id: int, thread: discord.Thread, author_id: int):
        super().__init__(timeout=None)
        self.cog = cog
        self.guild_id = guild_id
        self.thread = thread
        self.author_id = author_id

    @discord.ui.button(label="Accept", style=discord.ButtonStyle.success)
    async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self.cog._is_staff(interaction.user, interaction.guild.id):
            await interaction.response.send_message("You are not authorized.", ephemeral=True)
            return
        await interaction.response.send_message(f"Appeal accepted by {interaction.user.mention}", ephemeral=False)
        # notify user
        try:
            user = await self.cog.bot.fetch_user(self.author_id)
            await user.send(f"Your appeal in {interaction.guild.name} has been accepted by {interaction.user}. Staff may follow up in the thread.")
        except Exception:
            pass
        # log
        try:
            await self.cog.db.insert_action_log(interaction.guild.id, "appeal_accepted", target=str(self.author_id), moderator_id=interaction.user.id, reason=None, metadata=None)
        except Exception:
            pass

    @discord.ui.button(label="Reject", style=discord.ButtonStyle.danger)
    async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self.cog._is_staff(interaction.user, interaction.guild.id):
            await interaction.response.send_message("You are not authorized.", ephemeral=True)
            return
        await interaction.response.send_message(f"Appeal rejected by {interaction.user.mention}", ephemeral=False)
        try:
            user = await self.cog.bot.fetch_user(self.author_id)
            await user.send(f"Your appeal in {interaction.guild.name} has been rejected by {interaction.user}.")
        except Exception:
            pass
        try:
            await self.cog.db.insert_action_log(interaction.guild.id, "appeal_rejected", target=str(self.author_id), moderator_id=interaction.user.id, reason=None, metadata=None)
        except Exception:
            pass


class AppealsCog(commands.Cog):
    """Appeals: users DM the bot with `/appeal` to submit an appeal for a configured guild.
    Guild owners/admins can configure `appeals_enabled`, `appeals_channel`, `appeal_questions` (JSON array), and `appealable_actions` (JSON array).
    """
    def __init__(self, bot):
        self.bot = bot
        self.db = core_db.DB()
        self.bot.loop.create_task(self._init())

    @commands.hybrid_command(name="setreviewchannel", with_app_command=True)
    @commands.has_guild_permissions(administrator=True)
    @discord.app_commands.describe(channel="Channel to post automated review embeds and staff review threads")
    async def setreviewchannel(self, ctx: commands.Context, channel: discord.TextChannel | None = None):
        """Set or clear the auto-review channel for staff review threads and embeds."""
        gid = ctx.guild.id
        if channel is None:
            await self.db.set_guild_setting(gid, 'auto_review_channel', None)
            await ctx.send(f"Cleared the auto-review channel for this server.")
            return

        await self.db.set_guild_setting(gid, 'auto_review_channel', channel.id)
        await ctx.send(f"Set auto-review channel to {channel.mention}.")

    async def _init(self):
        await core_db.init_db(self.db.path)
        await self.db.connect()

    async def _is_staff(self, member: discord.Member, guild_id: int) -> bool:
        # simple check: manage_guild or manage_messages
        try:
            if member.guild is None:
                return False
            perms = member.guild_permissions
            return perms.manage_guild or perms.manage_messages or perms.administrator
        except Exception:
            return False

    @commands.hybrid_command(name="setappeals", description="Enable/disable appeals for this guild: on/off")
    @commands.has_guild_permissions(administrator=True)
    async def setappeals(self, ctx, state: str):
        state = state.lower()
        if state not in ("on", "off"):
            await ctx.send("State must be 'on' or 'off'.")
            return
        await self.db.set_guild_setting(ctx.guild.id, "appeals_enabled", "1" if state == "on" else "0")
        await ctx.send(f"Appeals set to {state}.")

    @commands.hybrid_command(name="setappealschannel", description="Set the channel where appeal threads will be created.")
    @discord.app_commands.describe(channel="Text channel where appeal threads will be created")
    @commands.has_guild_permissions(administrator=True)
    async def setappealschannel(self, ctx, channel: discord.TextChannel):
        await self.db.set_guild_setting(ctx.guild.id, "appeals_channel", str(channel.id))
        await ctx.send(f"Appeals channel set to {channel.mention}.")

    @commands.hybrid_command(name="setappealquestions", description="Set the appeal questions (semicolon-separated).")
    @discord.app_commands.describe(questions="Semicolon-separated list of questions to ask the appellant")
    @commands.has_guild_permissions(administrator=True)
    async def setappealquestions(self, ctx, *, questions: str):
        arr = [q.strip() for q in questions.split(";") if q.strip()]
        await self.db.set_guild_setting(ctx.guild.id, "appeal_questions", json.dumps(arr))
        await ctx.send(f"Saved {len(arr)} appeal questions.")

    @commands.hybrid_command(name="setappealableactions", description="Set which actions are appealable (comma-separated).")
    @discord.app_commands.describe(actions="Comma-separated list of appealable action names (e.g., ban,mute)")
    @commands.has_guild_permissions(administrator=True)
    async def setappealableactions(self, ctx, *, actions: str):
        arr = [a.strip() for a in actions.split(",") if a.strip()]
        await self.db.set_guild_setting(ctx.guild.id, "appealable_actions", json.dumps(arr))
        await ctx.send(f"Saved appealable actions: {', '.join(arr)}")

    @commands.command(name="appeal")
    @discord.app_commands.describe(guild_id="Optional guild ID to submit the appeal to")
    async def appeal(self, ctx, guild_id: int = None):
        """Submit an appeal via DM. Usage: `appeal <guild_id>` or run without args and follow prompts.
        """
        # Only allow in DMs
        if ctx.guild is not None:
            await ctx.send("Please DM me to submit an appeal.")
            return
        # determine guild
        target_guild = None
        if guild_id:
            target_guild = self.bot.get_guild(guild_id)
        else:
            # find mutual guilds where appeals enabled and user is a member
            mutual = []
            for g in self.bot.guilds:
                try:
                    m = g.get_member(ctx.author.id)
                    if m:
                        enabled = await self.db.get_guild_setting(g.id, "appeals_enabled")
                        if enabled == "1":
                            mutual.append(g)
                except Exception:
                    continue
            if not mutual:
                await ctx.send("No mutual servers have appeals enabled. Provide a `guild_id` to appeal to.")
                return
            if len(mutual) == 1:
                target_guild = mutual[0]
            else:
                # ask user to pick
                txt = "Multiple servers available. Reply with the number to choose:\n"
                for i, g in enumerate(mutual, 1):
                    txt += f"{i}. {g.name} (ID: {g.id})\n"
                await ctx.send(txt)
                try:
                    msg = await self.bot.wait_for("message", check=lambda m: m.author.id == ctx.author.id and m.channel == ctx.channel, timeout=60)
                    idx = int(msg.content.strip()) - 1
                    if 0 <= idx < len(mutual):
                        target_guild = mutual[idx]
                    else:
                        await ctx.send("Invalid selection.")
                        return
                except Exception:
                    await ctx.send("Timed out or invalid response.")
                    return

        if not target_guild:
            await ctx.send("Could not find the specified server or I am not in it.")
            return

        # check configuration
        enabled = await self.db.get_guild_setting(target_guild.id, "appeals_enabled")
        if enabled != "1":
            await ctx.send("Appeals are not enabled on that server.")
            return
        channel_id = await self.db.get_guild_setting(target_guild.id, "appeals_channel")
        if not channel_id:
            await ctx.send("That server has not configured an appeals channel.")
            return
        channel = target_guild.get_channel(int(channel_id))
        if not channel:
            await ctx.send("Appeals channel not found or I don't have access.")
            return

        # load questions
        rawq = await self.db.get_guild_setting(target_guild.id, "appeal_questions")
        if rawq:
            try:
                questions = json.loads(rawq)
            except Exception:
                questions = ["Why are you appealing?", "Explain the situation:"]
        else:
            questions = ["Why are you appealing?", "Explain the situation:"]

        answers = {}
        await ctx.send(f"Starting appeal for **{target_guild.name}**. Please answer the following questions.")
        for q in questions:
            await ctx.send(q)
            try:
                resp = await self.bot.wait_for("message", check=lambda m: m.author.id == ctx.author.id and m.channel == ctx.channel, timeout=300)
                answers[q] = resp.content
            except Exception:
                await ctx.send("Timed out waiting for response. Appeal cancelled.")
                return

        # ask which punishment
        await ctx.send("Which punishment are you appealing? (e.g., mute, ban, kick, other)")
        try:
            resp = await self.bot.wait_for("message", check=lambda m: m.author.id == ctx.author.id and m.channel == ctx.channel, timeout=60)
            appealed_action = resp.content.strip().lower()
        except Exception:
            await ctx.send("Timed out. Appeal cancelled.")
            return

        allowed_raw = await self.db.get_guild_setting(target_guild.id, "appealable_actions")
        if allowed_raw:
            try:
                allowed = json.loads(allowed_raw)
            except Exception:
                allowed = None
        else:
            allowed = None
        if allowed is not None and appealed_action not in allowed:
            await ctx.send(f"Appeals for `{appealed_action}` are not allowed on that server.")
            return

        # create an embed and post to appeals channel, then start a thread
        embed = discord.Embed(title=f"Appeal from {ctx.author}", color=discord.Color.orange())
        embed.add_field(name="User", value=f"{ctx.author} ({ctx.author.id})", inline=False)
        embed.add_field(name="Server", value=f"{target_guild.name} ({target_guild.id})", inline=False)
        embed.add_field(name="Punishment", value=appealed_action, inline=False)
        for q, a in answers.items():
            embed.add_field(name=q[:250], value=a[:1024], inline=False)

        try:
            msg = await channel.send(embed=embed)
            thread = await msg.create_thread(name=f"Appeal - {ctx.author.name}", auto_archive_duration=1440)
            view = AppealActionView(self, target_guild.id, thread, ctx.author.id)
            await msg.edit(view=view)
            await thread.send(f"Appeal thread for {ctx.author.mention}")
            await self.db.insert_action_log(target_guild.id, "appeal_submitted", target=str(ctx.author.id), moderator_id=None, reason=None, metadata=json.dumps({"answers": answers, "punishment": appealed_action}))
            await ctx.send("Your appeal has been submitted. Staff will review it in the server.")
        except Exception as e:
            await ctx.send(f"Failed to create appeal in server: {e}")


def setup(bot):
    bot.add_cog(AppealsCog(bot))
import discord
from discord.ext import commands
from datetime import datetime

class AppealsCog(commands.Cog):
    """DMs users when punished and provides an appeal link/form."""
    def __init__(self, bot):
        self.bot = bot
        self.appeal_url = "https://forms.gle/your-appeal-form"  # Replace with your real form

    async def send_punishment_dm(self, member, action, reason, moderator=None):
        embed = discord.Embed(
            title=f"You have been {action}",
            description=f"Reason: {reason}\n\nIf you believe this was a mistake, you can appeal using the link below.",
            color=discord.Color.red(),
            timestamp=datetime.utcnow()
        )
        embed.add_field(name="Appeal Link", value=f"[Appeal Here]({self.appeal_url})", inline=False)
        if moderator:
            embed.set_footer(text=f"Moderator: {moderator}")
        try:
            await member.send(embed=embed)
        except Exception:
            pass

    @commands.Cog.listener()
    async def on_member_ban(self, guild, user):
        # Try to DM before ban if possible (handled in mod cog), fallback here
        await self.send_punishment_dm(user, "banned", "(see server logs)")

    @commands.Cog.listener()
    async def on_member_remove(self, member):
        # Could be kick, but can't always distinguish
        pass

    @commands.Cog.listener()
    async def on_member_update(self, before, after):
        # Detect mute/timeouts (if supported)
        pass

def setup(bot):
    bot.add_cog(AppealsCog(bot))




# ---- FILE: villicus\bot\automessage_cog.py ----

# bot/automessage_cog.py
import discord
from discord.ext import commands, tasks
import datetime

class AutoMessageCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.automessages = []  # List of (channel_id, message, interval, next_time)
        self.check_automessages.start()

    @commands.hybrid_command(name="automessage", description="Set up an automatic timed message in a channel.")
    @commands.has_guild_permissions(administrator=True)
    async def automessage(self, ctx, channel: discord.TextChannel, interval: str, *, message: str):
        seconds = self.parse_time(interval)
        if seconds is None:
            await ctx.send("Invalid interval format. Use e.g. 10m, 2h, 1d.")
            return
        next_time = datetime.datetime.utcnow() + datetime.timedelta(seconds=seconds)
        self.automessages.append((channel.id, message, seconds, next_time))
        await ctx.send(f"Auto message set for {channel.mention} every {interval}.")

    @tasks.loop(seconds=30)
    async def check_automessages(self):
        now = datetime.datetime.utcnow()
        for i, (channel_id, message, interval, next_time) in enumerate(list(self.automessages)):
            if now >= next_time:
                channel = self.bot.get_channel(channel_id)
                if channel:
                    try:
                        await channel.send(message)
                    except Exception:
                        pass
                # Schedule next
                self.automessages[i] = (channel_id, message, interval, now + datetime.timedelta(seconds=interval))

    def parse_time(self, time_str):
        try:
            units = {"s": 1, "m": 60, "h": 3600, "d": 86400}
            if time_str.isdigit():
                return int(time_str)
            num = int(''.join(filter(str.isdigit, time_str)))
            unit = ''.join(filter(str.isalpha, time_str)).lower()
            return num * units.get(unit, 1)
        except Exception:
            return None

def setup(bot):
    bot.add_cog(AutoMessageCog(bot))




# ---- FILE: villicus\bot\automod_cog.py ----

# bot/automod_cog.py
import discord
from discord.ext import commands
import re

class AutoModCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.enabled = {}  # {guild_id: bool}
        self.banned_words = {}  # {guild_id: set(words)}
        self.max_mentions = {}  # {guild_id: int}

    @commands.hybrid_command(name="automod", description="Enable or disable automod features.")
    @commands.has_guild_permissions(administrator=True)
    async def automod(self, ctx, action: str):
        guild_id = ctx.guild.id
        if action.lower() == "enable":
            self.enabled[guild_id] = True
            await ctx.send("Automod enabled.")
        elif action.lower() == "disable":
            self.enabled[guild_id] = False
            await ctx.send("Automod disabled.")
        else:
            await ctx.send("Usage: automod <enable/disable>")

    @commands.hybrid_command(name="automod_banword", description="Add or remove banned words.")
    @commands.has_guild_permissions(administrator=True)
    async def automod_banword(self, ctx, action: str, word: str):
        guild_id = ctx.guild.id
        self.banned_words.setdefault(guild_id, set())
        if action == "add":
            self.banned_words[guild_id].add(word.lower())
            await ctx.send(f"Added banned word: {word}")
        elif action == "remove":
            self.banned_words[guild_id].discard(word.lower())
            await ctx.send(f"Removed banned word: {word}")
        else:
            await ctx.send("Usage: automod_banword <add/remove> <word>")

    @commands.hybrid_command(name="automod_maxmentions", description="Set max mentions per message.")
    @commands.has_guild_permissions(administrator=True)
    async def automod_maxmentions(self, ctx, count: int):
        guild_id = ctx.guild.id
        self.max_mentions[guild_id] = count
        await ctx.send(f"Set max mentions per message to {count}.")

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot or not message.guild:
            return
        guild_id = message.guild.id
        if not self.enabled.get(guild_id, False):
            return
        # Banned words
        banned = self.banned_words.get(guild_id, set())
        if banned:
            for word in banned:
                if re.search(rf"\\b{re.escape(word)}\\b", message.content, re.IGNORECASE):
                    await message.delete()
                    await message.channel.send(f"{message.author.mention}, that word is not allowed.", delete_after=5)
                    return
        # Max mentions
        max_m = self.max_mentions.get(guild_id)
        if max_m and len(message.mentions) > max_m:
            await message.delete()
            await message.channel.send(f"{message.author.mention}, too many mentions.", delete_after=5)
            return

def setup(bot):
    bot.add_cog(AutoModCog(bot))




# ---- FILE: villicus\bot\autoresponder_cog.py ----

# bot/autoresponder_cog.py
import discord
from discord.ext import commands

class AutoresponderCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.responses = {}  # {guild_id: [(trigger, response, cooldown)]}
        self.cooldowns = {}  # {guild_id: {trigger: {user_id: timestamp}}}

    @commands.hybrid_command(name="autoresponder", description="Add or remove autoresponses.")
    @commands.has_guild_permissions(administrator=True)
    async def autoresponder(self, ctx, action: str, trigger: str = None, response: str = None, cooldown: int = 0):
        guild_id = ctx.guild.id
        self.responses.setdefault(guild_id, [])
        if action == "add" and trigger and response:
            if len(self.responses[guild_id]) >= 20:
                await ctx.send("Max 20 autoresponses per server.")
                return
            self.responses[guild_id].append((trigger, response, cooldown))
            await ctx.send(f"Added autoresponse for '{trigger}'.")
        elif action == "remove" and trigger:
            self.responses[guild_id] = [r for r in self.responses[guild_id] if r[0] != trigger]
            await ctx.send(f"Removed autoresponse for '{trigger}'.")
        else:
            await ctx.send("Usage: autoresponder <add/remove> <trigger> <response> [cooldown]")

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot or not message.guild:
            return
        guild_id = message.guild.id
        for trigger, response, cooldown in self.responses.get(guild_id, []):
            if trigger.lower() in message.content.lower():
                # Cooldown per user per trigger
                self.cooldowns.setdefault(guild_id, {}).setdefault(trigger, {})
                last = self.cooldowns[guild_id][trigger].get(message.author.id, 0)
                now = discord.utils.utcnow().timestamp()
                if now - last < cooldown:
                    continue
                self.cooldowns[guild_id][trigger][message.author.id] = now
                await message.channel.send(response)
                break

def setup(bot):
    bot.add_cog(AutoresponderCog(bot))




# ---- FILE: villicus\bot\autorole_cog.py ----

# bot/afk_cog.py (already exists, skipping)
# bot/reminder_cog.py (already exists, skipping)
# bot/autorole_cog.py
import discord
from discord.ext import commands
import datetime
import json
from core import db as core_db


class AutoroleCog(commands.Cog):
    """Automatic and manual role assignment helpers.
    - Persistent join autoroles stored in guild setting `autorole_join` (JSON list of role IDs).
    - Timed assignments persisted in `autorole_timed` as JSON list of entries.
    - Commands: `addjoin`, `removejoin`, `listjoin`, `give`, `tempgive`.
    """
    def __init__(self, bot):
        self.bot = bot
        self.db = core_db.DB()
        self.join_roles = {}  # cache {guild_id: set(role_ids)}
        self.timed_roles = {}  # cache {guild_id: [entries]}
        self.bot.loop.create_task(self._init())

    async def _init(self):
        await core_db.init_db(self.db.path)
        await self.db.connect()
        await self._load_all()

    async def _load_all(self):
        for g in list(self.bot.guilds):
            raw = await self.db.get_guild_setting(g.id, "autorole_join")
            if raw:
                try:
                    self.join_roles[g.id] = set(json.loads(raw))
                except Exception:
                    self.join_roles[g.id] = set()
            else:
                self.join_roles[g.id] = set()
            rawt = await self.db.get_guild_setting(g.id, "autorole_timed")
            if rawt:
                try:
                    self.timed_roles[g.id] = json.loads(rawt)
                except Exception:
                    self.timed_roles[g.id] = []
            else:
                self.timed_roles[g.id] = []

    async def _save_join(self, guild_id: int):
        await self.db.set_guild_setting(guild_id, "autorole_join", json.dumps(list(self.join_roles.get(guild_id, set()))))

    async def _save_timed(self, guild_id: int):
        await self.db.set_guild_setting(guild_id, "autorole_timed", json.dumps(self.timed_roles.get(guild_id, [])))

    @commands.hybrid_command(name="addjoin", description="Add a role to autorole-on-join list.")
    @commands.has_guild_permissions(manage_guild=True)
    async def addjoin(self, ctx, role: discord.Role):
        gid = ctx.guild.id
        self.join_roles.setdefault(gid, set()).add(role.id)
        await self._save_join(gid)
        await ctx.send(f"{role.mention} will now be given to new members.")

    @commands.hybrid_command(name="removejoin", description="Remove a role from autorole-on-join list.")
    @commands.has_guild_permissions(manage_guild=True)
    async def removejoin(self, ctx, role: discord.Role):
        gid = ctx.guild.id
        self.join_roles.setdefault(gid, set()).discard(role.id)
        await self._save_join(gid)
        await ctx.send(f"{role.mention} removed from autoroles.")

    @commands.hybrid_command(name="listjoin", description="List join autoroles for this guild.")
    @commands.has_guild_permissions(manage_guild=True)
    async def listjoin(self, ctx):
        gid = ctx.guild.id
        roles = [ctx.guild.get_role(rid) for rid in sorted(self.join_roles.get(gid, set()))]
        if not roles:
            await ctx.send("No join autoroles configured.")
            return
        await ctx.send("Join autoroles: " + ", ".join(r.mention for r in roles if r))

    @commands.hybrid_command(name="give", description="Give a role to a member (quick assign).")
    @commands.has_guild_permissions(manage_roles=True)
    async def give(self, ctx, member: discord.Member, role: discord.Role):
        try:
            await member.add_roles(role, reason=f"Given by {ctx.author}")
            await ctx.send(f"Given {role.mention} to {member.mention}.")
        except Exception as e:
            await ctx.send(f"Failed to give role: {e}")

    @commands.hybrid_command(name="tempgive", description="Give a role to a member for a duration (e.g. 10m, 2h).")
    @commands.has_guild_permissions(manage_roles=True)
    async def tempgive(self, ctx, member: discord.Member, role: discord.Role, duration: str):
        gid = ctx.guild.id
        seconds = self.parse_time(duration)
        if seconds is None:
            await ctx.send("Invalid duration format. Use e.g. 10m, 2h, 1d.")
            return
        try:
            await member.add_roles(role, reason=f"Tempgiven by {ctx.author} for {duration}")
        except Exception as e:
            await ctx.send(f"Failed to give role: {e}")
            return
        entry = {"user_id": member.id, "role_id": role.id, "seconds": seconds, "start": datetime.datetime.utcnow().timestamp()}
        self.timed_roles.setdefault(gid, []).append(entry)
        await self._save_timed(gid)
        await ctx.send(f"{role.mention} given to {member.mention} for {duration}.")

    @commands.Cog.listener()
    async def on_member_join(self, member):
        gid = member.guild.id
        for rid in list(self.join_roles.get(gid, set())):
            role = member.guild.get_role(rid)
            if role:
                try:
                    await member.add_roles(role, reason="Autorole on join")
                except Exception:
                    pass

    @commands.Cog.listener()
    async def on_ready(self):
        self.bot.loop.create_task(self._check_timed())

    async def _check_timed(self):
        while True:
            now = datetime.datetime.utcnow().timestamp()
            for gid, lst in list(self.timed_roles.items()):
                for entry in list(lst):
                    if now - entry.get("start", 0) >= entry.get("seconds", 0):
                        guild = self.bot.get_guild(gid)
                        if not guild:
                            continue
                        member = guild.get_member(entry["user_id"]) if isinstance(entry.get("user_id"), int) else guild.get_member(int(entry.get("user_id")))
                        role = guild.get_role(entry["role_id"]) if isinstance(entry.get("role_id"), int) else guild.get_role(int(entry.get("role_id")))
                        if member and role:
                            try:
                                await member.remove_roles(role, reason="Timed autorole expired")
                            except Exception:
                                pass
                        try:
                            self.timed_roles[gid].remove(entry)
                        except Exception:
                            pass
                await self._save_timed(gid)
            await discord.utils.sleep_until(datetime.datetime.utcnow() + datetime.timedelta(seconds=30))

    def parse_time(self, time_str):
        try:
            units = {"s": 1, "m": 60, "h": 3600, "d": 86400}
            if time_str.isdigit():
                return int(time_str)
            num = int(''.join(filter(str.isdigit, time_str)))
            unit = ''.join(filter(str.isalpha, time_str)).lower()
            return num * units.get(unit, 1)
        except Exception:
            return None


def setup(bot):
    bot.add_cog(AutoroleCog(bot))




# ---- FILE: villicus\bot\avatar_cog.py ----

# bot/avatar_cog.py
import discord
from discord.ext import commands

class AvatarCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="avatar", description="Get a user's avatar.")
    async def avatar(self, ctx, member: discord.Member = None):
        member = member or ctx.author
        embed = discord.Embed(title=f"{member.display_name}'s Avatar", color=discord.Color.blurple())
        embed.set_image(url=member.display_avatar.url)
        await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(AvatarCog(bot))




# ---- FILE: villicus\bot\bot.py ----

# bot/bot.py
import discord
from discord.ext import commands
import discord
import asyncio
from core.config import get_prefix


# Set all recommended intents
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
intents.guilds = True
intents.guild_messages = True
intents.guild_reactions = True

# Channel ID for logging
LOG_CHANNEL_ID = 1442605619835179127

async def get_dynamic_prefix(bot, message):
    return await get_prefix(message.guild)

class VillicusBot(commands.Bot):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # ...existing code...

    async def on_command_error(self, ctx, error):
        if hasattr(ctx.command, 'on_error'):
            return
        embed = discord.Embed(
            title="❌ Oops! Something went wrong...",
            color=discord.Color.from_rgb(255, 215, 0)
        )
        if isinstance(error, commands.MissingRequiredArgument):
            embed.description = (
                f"{constants.VILLICUS_EMOJI} **Missing Required Input!**\n\n"
                f"**You must provide:** `{error.param.name}`\n\n"
                "*Tip: Use `/help <command>` or `/config` for guidance. All required fields are shown in the command preview above your message box.*"
            )
        elif isinstance(error, commands.BadArgument):
            embed.description = (
                f"{constants.VILLICUS_EMOJI} **Invalid input:** {error}\n\n"
                "Please check your command and try again."
            )
        elif isinstance(error, commands.MissingPermissions):
            embed.description = (
                f"{constants.VILLICUS_EMOJI} **You don't have permission to use this command.**\n"
                "If you believe this is a mistake, contact a server admin."
            )
        elif isinstance(error, commands.BotMissingPermissions):
            embed.description = (
                f"{constants.VILLICUS_EMOJI} **I need more permissions to do that!**\n"
                "Please check my role and permissions."
            )
        else:
            embed.description = (
                f"{constants.VILLICUS_EMOJI} **An unexpected error occurred.**\n"
                "If this keeps happening, contact the server owner or support."
            )
        embed.set_footer(text="Villicus | The Ultimate VIP Bot Experience ✨")
        try:
            await ctx.send(embed=embed, ephemeral=True)
        except Exception:
            pass




async def start_bot():
    print("[Villicus] Creating bot instance...")
    bot = commands.Bot(command_prefix=get_dynamic_prefix, intents=intents, help_command=None)

    try:
        print("[Villicus] Importing cogs...")
        from . import (
            config_cog, moderation_cog, help_cog, mod_commands_cog, ticket_cog, leveling_cog,
            actionlog_cog, antinuke_cog, autoresponder_cog, autorole_cog, avatar_cog, calculator_cog, clean_cog, color_cog, deafen_cog, embed_cog, emoji_cog, forms_cog, giveaway_cog, info_cog, lock_cog, nick_cog, owner_cog, purge_cog, reminder_cog, roleinfo_cog, servertag_cog, slowmode_cog, translate_cog, userinfo_cog, warnings_cog, welcome_cog, automessage_cog, automod_cog, invite_tracker_cog, polls_cog, reactionroles_cog, perfectlog_cog, appeals_cog, welcomemedia_cog, serverbackup_cog, rule_cog, smartautomod_cog, rule_analytics_cog
        )
        # Add all cogs
        await bot.add_cog(config_cog.ConfigCog(bot))
        await bot.add_cog(moderation_cog.ModerationCog(bot))
        await bot.add_cog(help_cog.HelpCog(bot))
        await bot.add_cog(mod_commands_cog.ModCommandsCog(bot))
        await bot.add_cog(ticket_cog.TicketCog(bot))
        await bot.add_cog(leveling_cog.LevelingCog(bot))
        await bot.add_cog(actionlog_cog.ActionLogCog(bot))
        await bot.add_cog(antinuke_cog.AntiNukeCog(bot))
        await bot.add_cog(autoresponder_cog.AutoresponderCog(bot))
        await bot.add_cog(autorole_cog.AutoroleCog(bot))
        await bot.add_cog(avatar_cog.AvatarCog(bot))
        await bot.add_cog(calculator_cog.CalculatorCog(bot))
        await bot.add_cog(clean_cog.CleanCog(bot))
        await bot.add_cog(color_cog.ColorCog(bot))
        await bot.add_cog(deafen_cog.DeafenCog(bot))
        await bot.add_cog(embed_cog.EmbedCog(bot))
        await bot.add_cog(emoji_cog.EmojiCog(bot))
        await bot.add_cog(forms_cog.FormsCog(bot))
        await bot.add_cog(giveaway_cog.GiveawayCog(bot))
        await bot.add_cog(info_cog.InfoCog(bot))
        await bot.add_cog(lock_cog.LockCog(bot))
        await bot.add_cog(nick_cog.NickCog(bot))
        await bot.add_cog(owner_cog.OwnerCog(bot))
        await bot.add_cog(purge_cog.PurgeCog(bot))
        await bot.add_cog(reminder_cog.ReminderCog(bot))
        await bot.add_cog(roleinfo_cog.RoleInfoCog(bot))
        await bot.add_cog(servertag_cog.ServerTagCog(bot))
        await bot.add_cog(slowmode_cog.SlowmodeCog(bot))
        await bot.add_cog(translate_cog.TranslateCog(bot))
        await bot.add_cog(userinfo_cog.UserInfoCog(bot))
        await bot.add_cog(warnings_cog.WarningsCog(bot))
        await bot.add_cog(welcome_cog.WelcomeCog(bot))
        await bot.add_cog(automessage_cog.AutoMessageCog(bot))
        await bot.add_cog(automod_cog.AutoModCog(bot))
        await bot.add_cog(invite_tracker_cog.InviteTrackerCog(bot))
        await bot.add_cog(polls_cog.PollsCog(bot))
        await bot.add_cog(reactionroles_cog.ReactionRolesCog(bot))
        await bot.add_cog(perfectlog_cog.PerfectLogCog(bot))
        await bot.add_cog(appeals_cog.AppealsCog(bot))
        await bot.add_cog(welcomemedia_cog.WelcomeMediaCog(bot))
        await bot.add_cog(serverbackup_cog.ServerBackupCog(bot))
        await bot.add_cog(rule_cog.RuleCog(bot))
        await bot.add_cog(smartautomod_cog.SmartAutoModCog(bot, rule_cog=bot.get_cog("RuleCog"), analytics_cog=bot.get_cog("RuleAnalyticsCog")))
        await bot.add_cog(rule_analytics_cog.RuleAnalyticsCog(bot))
    except Exception as e:
        import traceback
        print(f"[Villicus] Cog import/add error: {e}")
        traceback.print_exc()
        raise

    async def log_message(bot, content):
        await bot.wait_until_ready()
        channel = bot.get_channel(LOG_CHANNEL_ID)
        if channel:
            await channel.send(content)

    @bot.event
    async def on_ready():
        print(f"Villicus is online as {bot.user}")
        # Sync slash commands
        try:
            synced = await bot.tree.sync()
            await log_message(bot, f"✅ Synced {len(synced)} slash commands.")
        except Exception as e:
            await log_message(bot, f"❌ Slash command sync failed: {e}")


    @bot.event
    async def on_command_error(ctx, error):
        import discord.ext.commands as dpycmds
        if isinstance(error, dpycmds.errors.CommandNotFound):
            # Silently ignore unknown commands
            return
        await log_message(bot, f"❌ Command error in `{getattr(ctx, 'command', None)}` by {ctx.author} in #{ctx.channel}: {error}")
        # Do not raise error to avoid duplicate error output

    @bot.event
    async def on_command_completion(ctx):
        await log_message(bot, f"✅ Command `{ctx.command}` used by {ctx.author} in #{ctx.channel}")

    @bot.event
    async def on_guild_join(guild):
        await log_message(bot, f"➕ Joined new guild: {guild.name} (ID: {guild.id}) | Members: {guild.member_count}")

    @bot.event
    async def on_guild_remove(guild):
        await log_message(bot, f"➖ Removed from guild: {guild.name} (ID: {guild.id})")

    import os
    token = os.environ.get('VILLICUS_TOKEN')
    if not token:
        raise RuntimeError('VILLICUS_TOKEN environment variable not set!')
    await bot.start(token)




# ---- FILE: villicus\bot\calculator_cog.py ----

# villicus_combined_bot.py was converted to a placeholder during cleanup.
# The active Villicus entrypoint is `main.py` which imports from `bot` package.

"""
Disabled duplicate entry: villicus_combined_bot.py

This file used to provide a combined single-file bot. To avoid duplicate
entry points we disabled it and rely on the `bot` package and `main.py`.
"""

if __name__ == "__main__":
    print("villicus_combined_bot.py has been disabled; use Villicus-main/main.py instead.")

class CalculatorCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="calculator", description="Calculate a math expression.")
    async def calculator(self, ctx, *, expression: str):
        try:
            # Safe eval
            allowed = {"__builtins__": None}
            result = eval(expression, allowed, {})
            await ctx.send(f"Result: `{result}`")
        except Exception:
            await ctx.send("Invalid expression.")

def setup(bot):
    bot.add_cog(CalculatorCog(bot))




# ---- FILE: villicus\bot\clean_cog.py ----

# bot/clean_cog.py
import discord
from discord.ext import commands
from datetime import datetime, timedelta

class CleanCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="clean", description="Delete the past 3 days of a user's messages.")
    @commands.has_guild_permissions(manage_messages=True)
    async def clean(self, ctx, member: discord.Member):
        def is_target(m):
            return m.author.id == member.id and (datetime.utcnow() - m.created_at).days <= 3
        deleted = await ctx.channel.purge(limit=1000, check=is_target, bulk=True)
        await ctx.send(f"Deleted {len(deleted)} messages from {member.mention} in the past 3 days.", delete_after=5)

def setup(bot):
    bot.add_cog(CleanCog(bot))




# ---- FILE: villicus\bot\color_cog.py ----

# bot/color_cog.py
import discord
from discord.ext import commands
import io
from PIL import Image

class ColorCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="color", description="Show an image of a color from hex code.")
    async def color(self, ctx, hex_code: str):
        if not hex_code.startswith("#"):
            hex_code = f"#{hex_code}"
        try:
            rgb = tuple(int(hex_code.lstrip('#')[i:i+2], 16) for i in (0, 2, 4))
            img = Image.new("RGB", (128, 128), rgb)
            buf = io.BytesIO()
            img.save(buf, format="PNG")
            buf.seek(0)
            file = discord.File(buf, filename="color.png")
            embed = discord.Embed(title=f"Color: {hex_code}", color=int(hex_code.lstrip('#'), 16))
            embed.set_image(url="attachment://color.png")
            await ctx.send(embed=embed, file=file)
        except Exception:
            await ctx.send("Invalid hex code.")

def setup(bot):
    bot.add_cog(ColorCog(bot))




# ---- FILE: villicus\bot\config_cog.py ----

import discord
from discord.ext import commands
from discord import app_commands
from discord.ui import View, button
import json
from .mod_manager import ModManager


class WarnConfigView(View):
    def __init__(self, bot, guild_id: int, mod_manager: ModManager):
        super().__init__(timeout=300)
        self.bot = bot
        self.guild_id = guild_id
        self.mod_manager = mod_manager
        self.count = 3
        self.actions = ["mute", "tempban", "kick", "ban", "none"]
        self.action_idx = 0

    async def on_timeout(self):
        for child in self.children:
            child.disabled = True

    @button(label="-", style=discord.ButtonStyle.secondary)
    async def dec(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.count = max(0, self.count - 1)
        await interaction.response.edit_message(content=f"Warns → Punish after: **{self.count}** | Action: **{self.actions[self.action_idx]}**", view=self)

    @button(label="+", style=discord.ButtonStyle.secondary)
    async def inc(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.count += 1
        await interaction.response.edit_message(content=f"Warns → Punish after: **{self.count}** | Action: **{self.actions[self.action_idx]}**", view=self)

    @button(label="Action", style=discord.ButtonStyle.primary)
    async def action(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.action_idx = (self.action_idx + 1) % len(self.actions)
        await interaction.response.edit_message(content=f"Warns → Punish after: **{self.count}** | Action: **{self.actions[self.action_idx]}**", view=self)

    @button(label="Save", style=discord.ButtonStyle.success)
    async def save(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Save settings to DB
        await self.mod_manager.set_guild_setting(self.guild_id, "warns_to_punish", str(self.count))
        await self.mod_manager.set_guild_setting(self.guild_id, "warn_punish_action", self.actions[self.action_idx])
        await interaction.response.edit_message(content=f"Saved: {self.count} warns → {self.actions[self.action_idx]}", view=self)
        self.stop()


class ConfigCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        try:
            self.mod_manager = ModManager(bot)
        except Exception:
            self.mod_manager = None

    @commands.hybrid_command(name="setstaff", description="Assign a role a staff level (1-10).")
    @commands.has_guild_permissions(manage_guild=True)
    async def setstaff(self, ctx, role: discord.Role, level: int):
        if level < 1 or level > 10:
            await ctx.send("Level must be between 1 and 10.")
            return
        await self.mod_manager.add_staff_role(ctx.guild.id, role.id, level)
        await ctx.send(f"Set {role.mention} as staff level {level}.")

    @commands.hybrid_command(name="removestaff", description="Remove a staff role mapping.")
    @commands.has_guild_permissions(manage_guild=True)
    async def removestaff(self, ctx, role: discord.Role):
        await self.mod_manager.remove_staff_role(ctx.guild.id, role.id)
        await ctx.send(f"Removed {role.mention} from staff roles.")

    @commands.hybrid_command(name="liststaff", description="List configured staff roles and levels.")
    @commands.has_guild_permissions(manage_guild=True)
    async def liststaff(self, ctx):
        roles = await self.mod_manager.get_staff_roles(ctx.guild.id)
        if not roles:
            await ctx.send("No staff roles configured.")
            return
        lines = []
        for rid, lvl in roles.items():
            r = ctx.guild.get_role(int(rid))
            lines.append(f"{r.mention if r else rid} → Level {lvl}")
        await ctx.send("\n".join(lines))

    @app_commands.command(name="config", description="Configure Villicus settings interactively.")
    @app_commands.checks.has_permissions(administrator=True)
    async def config_slash(self, interaction: discord.Interaction):
        class ConfigMenu(discord.ui.View):
            def __init__(self):
                super().__init__(timeout=120)
                self.add_item(TicketButton())
                self.add_item(LazySetupButton())

        class LazySetupButton(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Lazy (Auto-Setup)", style=discord.ButtonStyle.success)
            async def callback(self, i: discord.Interaction):
                guild = i.guild
                try:
                    # Logging channel
                    log_channel = discord.utils.get(guild.text_channels, name="villicus-logs")
                    if not log_channel:
                        overwrites = {guild.default_role: discord.PermissionOverwrite(view_channel=False)}
                        log_channel = await guild.create_text_channel("villicus-logs", overwrites=overwrites, reason="Villicus Lazy Setup")
                    # Welcome channel
                    welcome_channel = discord.utils.get(guild.text_channels, name="welcome")
                    if not welcome_channel:
                        welcome_channel = await guild.create_text_channel("welcome", reason="Villicus Lazy Setup")
                    # Modlog channel
                    modlog_channel = discord.utils.get(guild.text_channels, name="modlog")
                    if not modlog_channel:
                        modlog_channel = await guild.create_text_channel("modlog", reason="Villicus Lazy Setup")
                    # Set up actionlog
                    actionlog_cog = i.client.get_cog("ActionLogCog")
                    if actionlog_cog:
                        actionlog_cog.log_channels[guild.id] = log_channel.id
                    # Set up basic ticket panel
                    ticket_cog = i.client.get_cog("TicketCog")
                    from .ticket_cog import TicketPanelButton
                    if ticket_cog:
                        view = TicketPanelButton("Support", [], "Open a ticket for help!", True)
                        embed = discord.Embed(title=f"{constants.TICKET_EMOJI} Support Ticket", description="Open a ticket for help!", color=discord.Color.from_rgb(255, 215, 0))
                        embed.set_footer(text="Click the button below to open a VIP ticket.")
                        msg = await log_channel.send(embed=embed, view=view)
                        ticket_cog.panels[log_channel.id] = {"ticket_type": "Support", "roles": [], "embed_text": "Open a ticket for help!", "use_thread": True, "message_id": msg.id}
                        try:
                            await ticket_cog.save_panels_for_guild(guild.id)
                        except Exception:
                            pass
                    # Set up antinuke
                    antinuke_cog = i.client.get_cog("AntiNukeCog")
                    if antinuke_cog:
                        antinuke_cog.enabled[guild.id] = True
                    # Set up automod (basic)
                    automod_cog = i.client.get_cog("AutoModCog")
                    if automod_cog:
                        automod_cog.enabled[guild.id] = True
                        automod_cog.max_mentions[guild.id] = 5
                        automod_cog.banned_words[guild.id] = ["badword1", "badword2"]
                    # Set up autoresponder (example)
                    autoresponder_cog = i.client.get_cog("AutoresponderCog")
                    if autoresponder_cog:
                        autoresponder_cog.responses.setdefault(guild.id, []).append({"trigger": "help", "response": "A staff member will be with you soon!"})
                    # Set up autorole (basic)
                    autorole_cog = i.client.get_cog("AutoroleCog")
                    if autorole_cog:
                        autorole_cog.join_roles[guild.id] = []
                    # Set up welcome message
                    welcome_cog = i.client.get_cog("WelcomeCog")
                    if welcome_cog:
                        welcome_cog.welcome_channel[guild.id] = welcome_channel.id
                        welcome_cog.welcome_message[guild.id] = "Welcome to the server, {user}!"
                        welcome_cog.welcome_ping[guild.id] = False
                    # Set up slowmode (default 5s in #general)
                    for c in guild.text_channels:
                        if c.name == "general":
                            try:
                                await c.edit(slowmode_delay=5, reason="Villicus Lazy Setup")
                            except Exception:
                                pass
                    embed = discord.Embed(
                        title="✅ VIP Lazy Setup Complete!",
                        description=(
                            f"**Logging:** {log_channel.mention}\n"
                            f"**Welcome:** {welcome_channel.mention}\n"
                            f"**Modlog:** {modlog_channel.mention}\n"
                            f"**Ticket panel:** created\n"
                            f"**Antinuke:** enabled\n"
                            f"**Automod:** enabled (max 5 mentions, basic banned words)\n"
                            f"**Autoresponder:** 'help' trigger added\n"
                            f"**Autorole:** none (customize in config)\n"
                            f"**Slowmode:** 5s in #general\n\n"
                            "You can further customize with the other config buttons."
                        ),
                        color=discord.Color.green()
                    )
                    embed.set_footer(text="Villicus | Instant Setup | The Ultimate Mod Bot")
                    await i.response.send_message(embed=embed, ephemeral=True)
                except Exception as e:
                    embed = discord.Embed(
                        title="❌ Lazy Setup Failed",
                        description=f"An error occurred during setup. Please check my permissions and try again.\nError: {e}",
                        color=discord.Color.red()
                    )
                    await i.response.send_message(embed=embed, ephemeral=True)

        class LevelingButton(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Leveling Setup", style=discord.ButtonStyle.primary)
            async def callback(self, button_interaction: discord.Interaction):
                await button_interaction.response.send_message(view=LevelingMenu(), ephemeral=True)

        class TicketButton(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Ticket Setup", style=discord.ButtonStyle.success)
            async def callback(self, button_interaction: discord.Interaction):
                await button_interaction.response.send_message(view=TicketMenu(), ephemeral=True)

        class LevelingMenu(discord.ui.View):
            def __init__(self):
                super().__init__(timeout=120)
                self.add_item(LevelRoleAdd())
                self.add_item(LevelRoleRemove())
                self.add_item(LevelChannelSet())

        class LevelRoleAdd(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Add Level Role", style=discord.ButtonStyle.primary)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(LevelRoleAddModal())

        class LevelRoleRemove(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Remove Level Role", style=discord.ButtonStyle.danger)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(LevelRoleRemoveModal())

        class LevelChannelSet(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Set Level-Up Channel", style=discord.ButtonStyle.secondary)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(LevelChannelSetModal())

        class LevelRoleAddModal(discord.ui.Modal, title="Add Level Role"):
            level = discord.ui.TextInput(label="Level", required=True)
            role_id = discord.ui.TextInput(label="Role ID", required=True)
            async def on_submit(self, i):
                cog = i.client.get_cog("LevelingCog")
                guild_id = i.guild.id
                level = int(self.level.value)
                role = i.guild.get_role(int(self.role_id.value))
                if not role:
                    await i.response.send_message("Invalid role ID.", ephemeral=True)
                    return
                cog.level_roles.setdefault(guild_id, {})
                cog.level_roles[guild_id][level] = role.id
                await i.response.send_message(f"Role <@&{role.id}> will be given at level {level}.", ephemeral=True)

        class LevelRoleRemoveModal(discord.ui.Modal, title="Remove Level Role"):
            level = discord.ui.TextInput(label="Level", required=True)
            async def on_submit(self, i):
                cog = i.client.get_cog("LevelingCog")
                guild_id = i.guild.id
                level = int(self.level.value)
                if level in cog.level_roles.get(guild_id, {}):
                    del cog.level_roles[guild_id][level]
                    await i.response.send_message(f"Role for level {level} removed.", ephemeral=True)
                else:
                    await i.response.send_message(f"No role set for level {level}.", ephemeral=True)

        class LevelChannelSetModal(discord.ui.Modal, title="Set Level-Up Channel"):
            channel_id = discord.ui.TextInput(label="Channel ID", required=True)
            message = discord.ui.TextInput(label="Level-up message (optional)", required=False)
            ping = discord.ui.TextInput(label="Ping user? true/false (optional)", required=False)
            async def on_submit(self, i):
                cog = i.client.get_cog("LevelingCog")
                guild_id = i.guild.id
                cog.level_channel[guild_id] = int(self.channel_id.value)
                if self.message.value:
                    cog.level_message[guild_id] = self.message.value
                if self.ping.value:
                    cog.level_ping[guild_id] = self.ping.value.lower() == "true"
                await i.response.send_message(f"Level-up messages will be sent in <#{self.channel_id.value}>. Message: {self.message.value or 'Default'} | Ping: {self.ping.value or 'false'}", ephemeral=True)

        class TicketMenu(discord.ui.View):
            def __init__(self):
                super().__init__(timeout=120)
                self.add_item(TicketPanelAdd())
                self.add_item(TicketPanelRemove())

        class TicketPanelAdd(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Add Ticket Panel", style=discord.ButtonStyle.primary)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(TicketPanelAddModal())

        class TicketPanelRemove(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Remove Ticket Panel", style=discord.ButtonStyle.danger)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(TicketPanelRemoveModal())

        class TicketPanelAddModal(discord.ui.Modal, title="Add Ticket Panel"):
            channel_id = discord.ui.TextInput(label="Channel ID (leave empty to use this channel)", required=False)
            ticket_type = discord.ui.TextInput(label="Ticket Type", required=True)
            roles = discord.ui.TextInput(label="Comma-separated role IDs (optional)", required=False)
            embed_text = discord.ui.TextInput(label="Panel embed text (optional)", required=False)
            use_thread = discord.ui.TextInput(label="Use thread? true/false (optional)", required=False)
            async def on_submit(self, i):
                from .ticket_cog import TicketPanelButton
                cog = i.client.get_cog("TicketCog")
                # Allow using current channel when no channel_id provided
                if not self.channel_id.value:
                    channel = i.channel
                else:
                    try:
                        channel = i.guild.get_channel(int(self.channel_id.value))
                    except Exception:
                        channel = None
                if not channel:
                    embed = discord.Embed(
                        title="❌ Invalid Channel",
                        description="The channel ID you provided is invalid. Please double-check and try again.",
                        color=discord.Color.red()
                    )
                    embed.set_footer(text="Villicus | VIP Ticket Setup")
                    await i.response.send_message(embed=embed, ephemeral=True)
                    return
                role_objs = []
                if self.roles.value:
                    for rid in self.roles.value.split(","):
                        role = i.guild.get_role(int(rid.strip()))
                        if role:
                            role_objs.append(role)
                view = TicketPanelButton(self.ticket_type.value, role_objs, self.embed_text.value or "Open a ticket!", self.use_thread.value.lower() == "true")
                embed = discord.Embed(title=f"{constants.TICKET_EMOJI} {self.ticket_type.value} Ticket", description=self.embed_text.value or "Open a ticket!", color=discord.Color.from_rgb(255, 215, 0))
                embed.set_footer(text="Click the button below to open a VIP ticket.")
                msg = await channel.send(embed=embed, view=view)
                cog.panels[channel.id] = {"ticket_type": self.ticket_type.value, "roles": [r.id for r in role_objs], "embed_text": self.embed_text.value or "Open a ticket!", "use_thread": self.use_thread.value.lower() == "true", "message_id": msg.id}
                try:
                    await cog.save_panels_for_guild(i.guild.id)
                except Exception:
                    pass
                embed2 = discord.Embed(
                    title=f"{constants.TICKET_EMOJI} VIP Ticket Panel Created!",
                    description=f"A ticket panel was created in <#{self.channel_id.value}>.\n\n**Type:** {self.ticket_type.value}\n**Roles:** {', '.join([r.mention for r in role_objs]) if role_objs else 'None'}\n**Thread:** {'Yes' if self.use_thread.value.lower() == 'true' else 'No'}",
                    color=discord.Color.from_rgb(255, 215, 0)
                )
                embed2.set_footer(text="Villicus | The Ultimate VIP Bot Experience ✨")
                await i.response.send_message(embed=embed2, ephemeral=True)

        class TicketPanelRemoveModal(discord.ui.Modal, title="Remove Ticket Panel"):
            channel_id = discord.ui.TextInput(label="Channel ID (leave empty to use this channel)", required=False)
            async def on_submit(self, i):
                from . import ticket_cog
                cog = i.client.get_cog("TicketCog")
                # Default to current channel when none provided
                if not self.channel_id.value:
                    channel = i.channel
                else:
                    try:
                        channel = i.guild.get_channel(int(self.channel_id.value))
                    except Exception:
                        channel = None
                if not channel:
                    await i.response.send_message("Invalid channel.", ephemeral=True)
                    return
                if channel.id in cog.panels:
                    try:
                        msg_id = cog.panels[channel.id]["message_id"]
                        msg = await channel.fetch_message(msg_id)
                        await msg.delete()
                    except Exception:
                        pass
                    del cog.panels[channel.id]
                    try:
                        await cog.save_panels_for_guild(i.guild.id)
                    except Exception:
                        pass
                    await i.response.send_message(f"Ticket panel removed from {channel.mention}.", ephemeral=True)
                else:
                    await i.response.send_message(f"No ticket panel found in {channel.mention}.", ephemeral=True)

        await interaction.response.send_message("Villicus Configuration Menu:", view=ConfigMenu(), ephemeral=True)
        class LevelingMenu(discord.ui.View):
            def __init__(self):
                super().__init__(timeout=120)
                self.add_item(LevelRoleAdd())
                self.add_item(LevelRoleRemove())
                self.add_item(LevelChannelSet())

        class LevelRoleAdd(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Add Level Role", style=discord.ButtonStyle.primary)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(LevelRoleAddModal())

        class LevelRoleRemove(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Remove Level Role", style=discord.ButtonStyle.danger)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(LevelRoleRemoveModal())

        class LevelChannelSet(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Set Level-Up Channel", style=discord.ButtonStyle.secondary)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(LevelChannelSetModal())

        class LevelRoleAddModal(discord.ui.Modal, title="Add Level Role"):
            level = discord.ui.TextInput(label="Level", required=True)
            role_id = discord.ui.TextInput(label="Role ID", required=True)
            async def on_submit(self, i):
                cog = i.client.get_cog("LevelingCog")
                guild_id = i.guild.id
                level = int(self.level.value)
                role = i.guild.get_role(int(self.role_id.value))
                if not role:
                    await i.response.send_message("Invalid role ID.", ephemeral=True)
                    return
                cog.level_roles.setdefault(guild_id, {})
                cog.level_roles[guild_id][level] = role.id
                await i.response.send_message(f"Role <@&{role.id}> will be given at level {level}.", ephemeral=True)

        class LevelRoleRemoveModal(discord.ui.Modal, title="Remove Level Role"):
            level = discord.ui.TextInput(label="Level", required=True)
            async def on_submit(self, i):
                cog = i.client.get_cog("LevelingCog")
                guild_id = i.guild.id
                level = int(self.level.value)
                if level in cog.level_roles.get(guild_id, {}):
                    del cog.level_roles[guild_id][level]
                    await i.response.send_message(f"Role for level {level} removed.", ephemeral=True)
                else:
                    await i.response.send_message(f"No role set for level {level}.", ephemeral=True)

        class LevelChannelSetModal(discord.ui.Modal, title="Set Level-Up Channel"):
            channel_id = discord.ui.TextInput(label="Channel ID", required=True)
            message = discord.ui.TextInput(label="Level-up message (optional)", required=False)
            ping = discord.ui.TextInput(label="Ping user? true/false (optional)", required=False)
            async def on_submit(self, i):
                cog = i.client.get_cog("LevelingCog")
                guild_id = i.guild.id
                cog.level_channel[guild_id] = int(self.channel_id.value)
                if self.message.value:
                    cog.level_message[guild_id] = self.message.value
                if self.ping.value:
                    cog.level_ping[guild_id] = self.ping.value.lower() == "true"
                await i.response.send_message(f"Level-up messages will be sent in <#{self.channel_id.value}>. Message: {self.message.value or 'Default'} | Ping: {self.ping.value or 'false'}", ephemeral=True)

        class TicketMenu(discord.ui.View):
            def __init__(self):
                super().__init__(timeout=120)
                self.add_item(TicketPanelAdd())
                self.add_item(TicketPanelRemove())

        class TicketPanelAdd(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Add Ticket Panel", style=discord.ButtonStyle.primary)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(TicketPanelAddModal())

        class TicketPanelRemove(discord.ui.Button):
            def __init__(self):
                super().__init__(label="Remove Ticket Panel", style=discord.ButtonStyle.danger)
            async def callback(self, i: discord.Interaction):
                await i.response.send_modal(TicketPanelRemoveModal())

        class TicketPanelAddModal(discord.ui.Modal, title="Add Ticket Panel"):
            channel_id = discord.ui.TextInput(label="Channel ID (leave empty to use this channel)", required=False)
            ticket_type = discord.ui.TextInput(label="Ticket Type", required=True)
            roles = discord.ui.TextInput(label="Comma-separated role IDs (optional)", required=False)
            embed_text = discord.ui.TextInput(label="Panel embed text (optional)", required=False)
            use_thread = discord.ui.TextInput(label="Use thread? true/false (optional)", required=False)
            async def on_submit(self, i):
                from .ticket_cog import TicketPanelButton
                cog = i.client.get_cog("TicketCog")
                # Allow using current channel when no channel_id provided
                if not self.channel_id.value:
                    channel = i.channel
                else:
                    try:
                        channel = i.guild.get_channel(int(self.channel_id.value))
                    except Exception:
                        channel = None
                if not channel:
                    embed = discord.Embed(
                        title="❌ Invalid Channel",
                        description="The channel ID you provided is invalid. Please double-check and try again.",
                        color=discord.Color.red()
                    )
                    embed.set_footer(text="Villicus | VIP Ticket Setup")
                    await i.response.send_message(embed=embed, ephemeral=True)
                    return
                role_objs = []
                if self.roles.value:
                    for rid in self.roles.value.split(","):
                        role = i.guild.get_role(int(rid.strip()))
                        if role:
                            role_objs.append(role)
                view = TicketPanelButton(self.ticket_type.value, role_objs, self.embed_text.value or "Open a ticket!", self.use_thread.value.lower() == "true")
                embed = discord.Embed(title=f"{constants.TICKET_EMOJI} {self.ticket_type.value} Ticket", description=self.embed_text.value or "Open a ticket!", color=discord.Color.from_rgb(255, 215, 0))
                embed.set_footer(text="Click the button below to open a VIP ticket.")
                msg = await channel.send(embed=embed, view=view)
                cog.panels[channel.id] = {"ticket_type": self.ticket_type.value, "roles": [r.id for r in role_objs], "embed_text": self.embed_text.value or "Open an ticket!", "use_thread": self.use_thread.value.lower() == "true", "message_id": msg.id}
                try:
                    await cog.save_panels_for_guild(i.guild.id)
                except Exception:
                    pass
                embed2 = discord.Embed(
                    title=f"{constants.TICKET_EMOJI} VIP Ticket Panel Created!",
                    description=f"A ticket panel was created in <#{self.channel_id.value}>.\n\n**Type:** {self.ticket_type.value}\n**Roles:** {', '.join([r.mention for r in role_objs]) if role_objs else 'None'}\n**Thread:** {'Yes' if self.use_thread.value.lower() == 'true' else 'No'}",
                    color=discord.Color.from_rgb(255, 215, 0)
                )
                embed2.set_footer(text="Villicus | The Ultimate VIP Bot Experience ✨")
                await i.response.send_message(embed=embed2, ephemeral=True)

        class TicketPanelRemoveModal(discord.ui.Modal, title="Remove Ticket Panel"):
            channel_id = discord.ui.TextInput(label="Channel ID (leave empty to use this channel)", required=False)
            async def on_submit(self, i):
                from . import ticket_cog
                cog = i.client.get_cog("TicketCog")
                # Default to current channel when none provided
                if not self.channel_id.value:
                    channel = i.channel
                else:
                    try:
                        channel = i.guild.get_channel(int(self.channel_id.value))
                    except Exception:
                        channel = None
                if not channel:
                    await i.response.send_message("Invalid channel.", ephemeral=True)
                    return
                if channel.id in cog.panels:
                    try:
                        msg_id = cog.panels[channel.id]["message_id"]
                        msg = await channel.fetch_message(msg_id)
                        await msg.delete()
                    except Exception:
                        pass
                    del cog.panels[channel.id]
                    try:
                        await cog.save_panels_for_guild(i.guild.id)
                    except Exception:
                        pass
                    await i.response.send_message(f"Ticket panel removed from {channel.mention}.", ephemeral=True)
                else:
                    await i.response.send_message(f"No ticket panel found in {channel.mention}.", ephemeral=True)

        await interaction.response.send_message("Villicus Configuration Menu:", view=ConfigMenu(), ephemeral=True)






# ---- FILE: villicus\bot\deafen_cog.py ----

# bot/deafen_cog.py
import discord
from discord.ext import commands
from datetime import timedelta

class DeafenCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="deafen", description="Deafen a user for a duration.")
    @commands.has_guild_permissions(deafen_members=True)
    async def deafen(self, ctx, member: discord.Member, duration: str = None):
        if not member.voice:
            await ctx.send("User is not in a voice channel.")
            return
        await member.edit(deafen=True)
        await ctx.send(f"{member.mention} has been deafened.")
        if duration:
            seconds = self.parse_time(duration)
            if seconds:
                await discord.utils.sleep_until(discord.utils.utcnow() + timedelta(seconds=seconds))
                await member.edit(deafen=False)
                await ctx.send(f"{member.mention} has been undeafened.")

    @commands.hybrid_command(name="undeafen", description="Undeafen a user.")
    @commands.has_guild_permissions(deafen_members=True)
    async def undeafen(self, ctx, member: discord.Member):
        await member.edit(deafen=False)
        await ctx.send(f"{member.mention} has been undeafened.")

    def parse_time(self, time_str):
        try:
            units = {"s": 1, "m": 60, "h": 3600, "d": 86400}
            if time_str.isdigit():
                return int(time_str)
            num = int(''.join(filter(str.isdigit, time_str)))
            unit = ''.join(filter(str.isalpha, time_str)).lower()
            return num * units.get(unit, 1)
        except Exception:
            return None

def setup(bot):
    bot.add_cog(DeafenCog(bot))




# ---- FILE: villicus\bot\embed_cog.py ----

# bot/embed_cog.py
import discord
from discord.ext import commands

class EmbedCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="embed", description="Send a beautiful embed message.")
    @commands.has_guild_permissions(manage_messages=True)
    async def embed(self, ctx, *, text: str):
        embed = discord.Embed(description=text, color=discord.Color.blurple())
        embed.set_author(name=ctx.author.display_name, icon_url=ctx.author.display_avatar.url)
        await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(EmbedCog(bot))




# ---- FILE: villicus\bot\emoji_cog.py ----

# bot/emoji_cog.py
import discord
from discord.ext import commands

class EmojiCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="emoji", description="Create, remove, or lock an emoji.")
    @commands.has_guild_permissions(manage_emojis=True)
    async def emoji(self, ctx, action: str, name: str, image_url: str = None, role: discord.Role = None):
        guild = ctx.guild
        if action == "create":
            if not image_url:
                await ctx.send("Provide an image URL for the emoji.")
                return
            try:
                async with ctx.bot.session.get(image_url) as resp:
                    if resp.status != 200:
                        await ctx.send("Failed to fetch image.")
                        return
                    img = await resp.read()
                emoji = await guild.create_custom_emoji(name=name, image=img)
                await ctx.send(f"Created emoji: <:{emoji.name}:{emoji.id}>")
            except Exception:
                await ctx.send("Failed to create emoji.")
        elif action == "remove":
            emoji = discord.utils.get(guild.emojis, name=name)
            if emoji:
                await emoji.delete()
                await ctx.send(f"Removed emoji: {name}")
            else:
                await ctx.send("Emoji not found.")
        elif action == "lock":
            emoji = discord.utils.get(guild.emojis, name=name)
            if emoji and role:
                await emoji.edit(roles=[role])
                # Add all roles above this role
                above = [r for r in guild.roles if r.position > role.position]
                await emoji.edit(roles=[role] + above)
                await ctx.send(f"Locked emoji {name} to {role.mention} and above.")
            else:
                await ctx.send("Emoji or role not found.")
        else:
            await ctx.send("Usage: emoji <create/remove/lock> <name> [image_url if create] [@role if lock]")

def setup(bot):
    bot.add_cog(EmojiCog(bot))




# ---- FILE: villicus\bot\forms_cog.py ----

# bot/forms_cog.py
import discord
from discord.ext import commands

class FormsCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.forms = {}  # {guild_id: {form_name: [questions]}}
        self.responses = {}  # {guild_id: {form_name: [responses]}}

    @commands.hybrid_command(name="form_create", description="Create a new form.")
    @commands.has_guild_permissions(administrator=True)
    async def form_create(self, ctx, form_name: str, *, questions: str):
        guild_id = ctx.guild.id
        qs = [q.strip() for q in questions.split(';') if q.strip()]
        self.forms.setdefault(guild_id, {})[form_name] = qs
        await ctx.send(f"Form '{form_name}' created with {len(qs)} questions.")

    @commands.hybrid_command(name="form_fill", description="Fill out a form.")
    async def form_fill(self, ctx, form_name: str):
        guild_id = ctx.guild.id
        form = self.forms.get(guild_id, {}).get(form_name)
        if not form:
            await ctx.send("Form not found.")
            return
        answers = []
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel
        for q in form:
            await ctx.send(q)
            try:
                msg = await self.bot.wait_for('message', check=check, timeout=120)
                answers.append(msg.content)
            except Exception:
                await ctx.send("Timed out. Please try again.")
                return
        self.responses.setdefault(guild_id, {}).setdefault(form_name, []).append((ctx.author.id, answers))
        await ctx.send("Form submitted!")
        # Send to admin channel if exists
        admin_channel = next((c for c in ctx.guild.text_channels if c.permissions_for(ctx.guild.me).administrator), None)
        if admin_channel:
            embed = discord.Embed(title=f"Form Submission: {form_name}", color=discord.Color.green())
            embed.add_field(name="User", value=ctx.author.mention)
            for i, (q, a) in enumerate(zip(form, answers), 1):
                embed.add_field(name=f"Q{i}: {q}", value=a, inline=False)
            await admin_channel.send(embed=embed)

def setup(bot):
    bot.add_cog(FormsCog(bot))




# ---- FILE: villicus\bot\giveaway_cog.py ----

# bot/giveaway_cog.py
import discord
from discord.ext import commands, tasks
from discord import app_commands
import random
import json
import asyncio
from core import db as core_db


def _parse_duration(duration: str) -> int | None:
    try:
        num = int(''.join(filter(str.isdigit, duration)))
        unit = ''.join(filter(str.isalpha, duration)).lower()
        return num * (86400 if unit == 'd' else 3600 if unit == 'h' else 60 if unit == 'm' else 1)
    except Exception:
        return None


class GiveawayCog(commands.Cog):
    """Persistent giveaways: create, end, reroll. Stores active giveaways in `guild_settings` under key `giveaways`.
    Each giveaway stored as message_id -> {channel_id, prize, host_id, ends_at, winners_count}
    """
    def __init__(self, bot):
        self.bot = bot
        self.db = core_db.DB()
        self._tasks = {}  # message_id -> asyncio.Task
        self.bot.loop.create_task(self._init())

    async def _init(self):
        await core_db.init_db(self.db.path)
        await self.db.connect()
        await self._load_and_schedule()

    async def _load_and_schedule(self):
        # Load all guilds' giveaways and schedule expirations
        rows = await self.db.fetchall("SELECT guild_id, key, value FROM guild_settings WHERE key = 'giveaways'")
        for r in rows:
            guild_id = int(r['guild_id'])
            try:
                data = json.loads(r['value']) if r['value'] else {}
            except Exception:
                data = {}
            for msgid, g in data.items():
                try:
                    ends = int(g.get('ends_at', 0))
                    delay = max(0, ends - int(__import__('time').time()))
                    task = asyncio.create_task(self._wait_and_finish(int(msgid), guild_id, delay))
                    self._tasks[int(msgid)] = task
                except Exception:
                    continue

    async def _save_giveaway(self, guild_id: int, giveaways: dict):
        await self.db.set_guild_setting(guild_id, 'giveaways', json.dumps(giveaways))

    async def _wait_and_finish(self, message_id: int, guild_id: int, delay: int):
        await asyncio.sleep(delay)
        try:
            # attempt to fetch data
            raw = await self.db.get_guild_setting(guild_id, 'giveaways')
            data = json.loads(raw) if raw else {}
            g = data.get(str(message_id))
            if not g:
                return
            channel = self.bot.get_channel(int(g['channel_id']))
            if not channel:
                return
            try:
                msg = await channel.fetch_message(int(message_id))
            except Exception:
                return
            users = []
            for reaction in msg.reactions:
                if reaction.emoji == "🎉":
                    users = [u async for u in reaction.users() if not u.bot]
                    break
            if not users:
                await channel.send("No valid entries for giveaway.")
            else:
                winners = []
                count = int(g.get('winners_count', 1))
                for _ in range(min(count, len(users))):
                    winner = random.choice(users)
                    winners.append(winner)
                    users.remove(winner)
                await channel.send("🎉 Winner(s): " + ", ".join(w.mention for w in winners))
            # remove from storage
            data.pop(str(message_id), None)
            await self._save_giveaway(guild_id, data)
            self._tasks.pop(message_id, None)
        except Exception:
            return

    @app_commands.command(name="giveaway", description="Create a giveaway in this channel.")
    @app_commands.describe(duration="Duration (e.g. 1d, 3h)", prize="Prize description", winners="Number of winners")
    @app_commands.checks.has_permissions(manage_guild=True)
    async def slash_giveaway(self, interaction: discord.Interaction, duration: str, prize: str, winners: int = 1):
        await interaction.response.defer(ephemeral=False)
        secs = _parse_duration(duration)
        if secs is None or secs <= 0:
            await interaction.followup.send("Invalid duration format. Use e.g. 1d, 3h, 30m.")
            return
        embed = discord.Embed(title="🎉 Giveaway", description=f"Prize: {prize}\nHosted by: {interaction.user.mention}", color=discord.Color.green())
        embed.add_field(name="Ends", value=f"<t:{int(__import__('time').time()) + secs}:F>")
        msg = await interaction.channel.send(embed=embed)
        try:
            await msg.add_reaction("🎉")
        except Exception:
            pass
        # persist
        raw = await self.db.get_guild_setting(interaction.guild.id, 'giveaways')
        data = json.loads(raw) if raw else {}
        data[str(msg.id)] = {
            'channel_id': str(interaction.channel.id),
            'prize': prize,
            'host_id': str(interaction.user.id),
            'ends_at': int(__import__('time').time()) + secs,
            'winners_count': int(winners)
        }
        await self._save_giveaway(interaction.guild.id, data)
        # schedule
        task = asyncio.create_task(self._wait_and_finish(msg.id, interaction.guild.id, secs))
        self._tasks[msg.id] = task
        await interaction.followup.send(f"Giveaway created: {prize} — ends in {duration}.")

    @app_commands.command(name="giveaway_end", description="End an active giveaway now (by message id).")
    @app_commands.describe(message_id="Message ID of the giveaway to end")
    @app_commands.checks.has_permissions(manage_guild=True)
    async def slash_giveaway_end(self, interaction: discord.Interaction, message_id: int):
        await interaction.response.defer(ephemeral=True)
        raw = await self.db.get_guild_setting(interaction.guild.id, 'giveaways')
        data = json.loads(raw) if raw else {}
        g = data.get(str(message_id))
        if not g:
            await interaction.followup.send("Giveaway not found.", ephemeral=True)
            return
        # cancel task if scheduled
        t = self._tasks.pop(message_id, None)
        if t:
            t.cancel()
        # finish immediately
        await self._wait_and_finish(message_id, interaction.guild.id, 0)
        await interaction.followup.send("Giveaway ended.", ephemeral=True)

    @app_commands.command(name="giveaway_reroll", description="Reroll a giveaway winner by message id.")
    @app_commands.describe(message_id="Message ID of the giveaway to reroll")
    @app_commands.checks.has_permissions(manage_guild=True)
    async def slash_giveaway_reroll(self, interaction: discord.Interaction, message_id: int):
        await interaction.response.defer(ephemeral=False)
        # attempt to find message in channel history if not stored
        raw = await self.db.get_guild_setting(interaction.guild.id, 'giveaways')
        data = json.loads(raw) if raw else {}
        # if giveaway still active, we can't reroll; allow reroll only if message exists and has reactions
        try:
            # try to fetch message from any channel
            found = None
            for ch in interaction.guild.text_channels:
                try:
                    msg = await ch.fetch_message(message_id)
                    found = msg
                    break
                except Exception:
                    continue
            if not found:
                await interaction.followup.send("Giveaway message not found.")
                return
            users = []
            for reaction in found.reactions:
                if reaction.emoji == "🎉":
                    users = [u async for u in reaction.users() if not u.bot]
                    break
            if not users:
                await interaction.followup.send("No valid entries.")
                return
            winner = random.choice(users)
            await interaction.followup.send(f"🎉 New winner: {winner.mention}")
        except Exception as e:
            await interaction.followup.send(f"Reroll failed: {e}")

    @app_commands.command(name="giveaway_list", description="List active giveaways in this guild.")
    @app_commands.checks.has_permissions(manage_guild=True)
    async def slash_giveaway_list(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        raw = await self.db.get_guild_setting(interaction.guild.id, 'giveaways')
        data = json.loads(raw) if raw else {}
        if not data:
            await interaction.followup.send("No active giveaways.", ephemeral=True)
            return
        lines = []
        for mid, g in data.items():
            ends = int(g.get('ends_at', 0))
            lines.append(f"ID: {mid} — Prize: {g.get('prize')} — Ends: <t:{ends}:F>")
        await interaction.followup.send("\n".join(lines), ephemeral=True)


async def setup(bot):
    await bot.add_cog(GiveawayCog(bot))




# ---- FILE: villicus\bot\help_cog.py ----

# bot/help_cog.py

import discord
from discord.ext import commands

class HelpCog(commands.Cog):
    """Cog for Villicus help command (prefix and slash)."""
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="help", description="Show all Villicus commands and features, or help for a specific command.")
    async def help_command(self, ctx: commands.Context, command: str = None):
        """Displays a modern VIP embed with all commands and features, or help for a specific command."""
        help_texts = {
            "ban": "Ban a user from the server.\nUsage: V!ban @user <reason> or /ban @user <reason>",
            "kick": "Kick a user from the server.\nUsage: V!kick @user <reason> or /kick @user <reason>",
            "warn": "Warn a user.\nUsage: V!warn @user <reason> <duration> or /warn @user <reason> <duration> (default 30d)",
            "mute": "Mute a user for a duration.\nUsage: V!mute @user <duration> <reason> or /mute @user <duration> <reason>",
            "tempban": "Temporarily ban a user.\nUsage: V!tempban @user <duration> <reason> or /tempban @user <duration> <reason>",
            "softban": "Softban a user (ban and unban to delete messages).\nUsage: V!softban @user <reason> or /softban @user <reason>",
            "unban": "Unban a user.\nUsage: V!unban <user id/name#discrim> or /unban <user>",
            "unmute": "Unmute a user.\nUsage: V!unmute @user or /unmute @user",
            "deafen": "Deafen a user.\nUsage: V!deafen @user <duration> or /deafen @user <duration>",
            "undeafen": "Undeafen a user.\nUsage: V!undeafen @user or /undeafen @user",
            "clean": "Delete the past 3 days of a user's messages.\nUsage: V!clean @user or /clean @user",
            "purge": "Purge messages.\nUsage: V!purge <all/human/bots> <count> or /purge <all/human/bots> <count>",
            "lock": "Lock a channel.\nUsage: V!lock [#channel] [duration] or /lock [#channel] [duration]",
            "unlock": "Unlock a channel.\nUsage: V!unlock [#channel] or /unlock [#channel]",
            "slowmode": "Set slowmode.\nUsage: V!slowmode <seconds> [#channel] or /slowmode <seconds> [#channel]",
            "warnings": "Show warnings.\nUsage: V!warnings @user or /warnings @user",
            "ticket": "Ticket system.\nUsage: V!ticket ...",
            "welcome": "Set welcome message.\nUsage: V!welcome <message> <ping> or /welcome <message> <ping>",
            "automessage": "Auto post messages.\nUsage: V!automessage <#channel> <interval> <message> or /automessage ...",
            "embed": "Send an embed.\nUsage: V!embed <text> or /embed <text>",
            "autorole": "Autoroles.\nUsage: V!autorole <join/timed> <add/remove> <role> [duration] [member]",
            "nick": "Change nickname.\nUsage: V!nick @user <nickname> or /nick @user <nickname>",
            "roleinfo": "Role info.\nUsage: V!roleinfo <role> or /roleinfo <role>",
            "userinfo": "User info.\nUsage: V!userinfo @user or /userinfo @user",
            "color": "Show color.\nUsage: V!color <hex> or /color <hex>",
            "avatar": "Show avatar.\nUsage: V!avatar @user or /avatar @user",
            "calculator": "Math answers.\nUsage: V!calculator <expr> or /calculator <expr>",
            "giveaway": "Giveaways.\nUsage: V!giveaway <create/reroll/end/help> ...",
            "translate": "Translate.\nUsage: V!translate <lang> <message/link> or /translate <lang> <message/link>",
            "emoji": "Emoji management.\nUsage: V!emoji <create/remove/lock> <name> [url] [@role]",
            "autoresponder": "Autoresponder.\nUsage: V!autoresponder <add/remove> <trigger> <response> [cooldown]",
            "servertag": "Server tag roles.\nUsage: V!servertag <add/remove/enable/disable> <@role> [enable/disable]",
            "antinuke": "Anti-nuke/raid/spam.\nUsage: V!antinuke <enable/disable> [raid] [spam]",
            "info": "Bot info.\nUsage: V!info or /info",
            "ping": "Bot ping.\nUsage: V!ping or /ping",
        }
        if command:
            cmd = command.lower()
            desc = help_texts.get(cmd, f"No help found for `{cmd}`.")
            embed = discord.Embed(title=f"Help: {cmd}", description=desc, color=discord.Color.gold())
            embed.set_footer(text="Villicus | VIP Help")
            await ctx.reply(embed=embed, ephemeral=False)
            return
        embed = discord.Embed(
            title="Villicus Help Center",
            description="**The Ultimate Discord Mod Bot**\nAll commands are available as both prefix (`V!`) and slash (`/`) commands.\nUse `/config` for instant, interactive setup.",
            color=discord.Color.gold()
        )
        embed.add_field(name="Moderation", value="ban, kick, warn, mute, tempban, softban, unban, unmute, deafen, undeafen, clean, purge, lock, unlock, slowmode, warnings, antinuke", inline=False)
        embed.add_field(name="Community & Utility", value="welcome, automessage, embed, autorole, nick, roleinfo, userinfo, color, avatar, calculator, autoresponder, servertag, ticket, translate, emoji, giveaway", inline=False)
        embed.add_field(name="Owner & Fun", value="funfact, 8ball, eval, sayas", inline=False)
        embed.set_footer(text="Use V!help <command> or /help <command> for details. | Made by Psyvrse | VIP Experience ✨")
        await ctx.reply(embed=embed, ephemeral=False)




# ---- FILE: villicus\bot\info_cog.py ----

# bot/info_cog.py
import discord
from discord.ext import commands
import platform
import psutil

class InfoCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="info", description="Show bot info and stats.")
    async def info(self, ctx):
        embed = discord.Embed(title="Villicus Bot Info", color=discord.Color.blurple())
        embed.add_field(name="Servers", value=str(len(self.bot.guilds)))
        embed.add_field(name="Users", value=str(len(self.bot.users)))
        embed.add_field(name="Ping", value=f"{round(self.bot.latency*1000)}ms")
        embed.add_field(name="Support", value="[Support Server](https://discord.gg/psyvrse)")
        embed.add_field(name="Team", value="Psyvrse")
        embed.add_field(name="Python", value=platform.python_version())
        embed.add_field(name="Memory", value=f"{psutil.virtual_memory().percent}% used")
        embed.set_footer(text="Villicus - The Ultimate Mod Bot")
        await ctx.send(embed=embed)

    @commands.hybrid_command(name="ping", description="Get the bot's ping.")
    async def ping(self, ctx):
        await ctx.send(f"Pong! **bonk** `{round(self.bot.latency*1000)}ms`")

def setup(bot):
    bot.add_cog(InfoCog(bot))




# ---- FILE: villicus\bot\invite_tracker_cog.py ----

import discord
from discord.ext import commands, tasks
from collections import defaultdict

class InviteTrackerCog(commands.Cog):
    """Tracks server invites, shows leaderboards, and detects fake joins."""
    def __init__(self, bot):
        self.bot = bot
        self.invites = defaultdict(dict)  # guild_id: {code: uses}
        self.inviter_map = defaultdict(dict)  # guild_id: {user_id: inviter_id}
        self.update_invites.start()

    def cog_unload(self):
        self.update_invites.cancel()

    @tasks.loop(minutes=5)
    async def update_invites(self):
        for guild in self.bot.guilds:
            try:
                invites = await guild.invites()
                self.invites[guild.id] = {invite.code: invite.uses for invite in invites}
            except Exception:
                pass

    @commands.Cog.listener()
    async def on_member_join(self, member):
        try:
            invites_before = self.invites.get(member.guild.id, {})
            invites_after = {invite.code: invite.uses for invite in await member.guild.invites()}
            used_code = None
            for code, uses in invites_after.items():
                if uses > invites_before.get(code, 0):
                    used_code = code
                    break
            if used_code:
                inviter = next((invite.inviter for invite in await member.guild.invites() if invite.code == used_code), None)
                if inviter:
                    self.inviter_map[member.guild.id][member.id] = inviter.id
                    channel = discord.utils.get(member.guild.text_channels, name="welcome")
                    if channel:
                        await channel.send(f"{member.mention} joined using {inviter.mention}'s invite! 🎉")
        except Exception:
            pass
        # Update cache
        try:
            invites = await member.guild.invites()
            self.invites[member.guild.id] = {invite.code: invite.uses for invite in invites}
        except Exception:
            pass

    @commands.hybrid_command(name="invites", description="Show your invite stats.")
    async def invites(self, ctx, member: discord.Member = None):
        member = member or ctx.author
        guild_id = ctx.guild.id
        count = sum(1 for uid, inviter in self.inviter_map[guild_id].items() if inviter == member.id)
        embed = discord.Embed(
            title="🎉 Invite Tracker",
            description=f"{member.mention} has invited **{count}** member(s)!",
            color=discord.Color.from_rgb(255, 215, 0)
        )
        embed.set_footer(text="Villicus | VIP Experience ✨")
        await ctx.send(embed=embed)

    @commands.hybrid_command(name="invite_leaderboard", description="Show the top inviters.")
    async def invite_leaderboard(self, ctx):
        guild_id = ctx.guild.id
        counter = defaultdict(int)
        for uid, inviter in self.inviter_map[guild_id].items():
            counter[inviter] += 1
        top = sorted(counter.items(), key=lambda x: x[1], reverse=True)[:10]
        desc = "\n".join(f"<@{uid}>: {count}" for uid, count in top) or "No invites tracked yet."
        embed = discord.Embed(title="Invite Leaderboard", description=desc, color=discord.Color.blurple())
        await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(InviteTrackerCog(bot))




# ---- FILE: villicus\bot\leveling_cog.py ----

# bot/leveling_cog.py

import discord
from discord.ext import commands
from discord import app_commands
import random
import math

LEVEL_PERMS = ["manage_guild", "manage_channels", "administrator", "manage_webhooks"]

def has_level_perms(ctx):
    perms = ctx.author.guild_permissions
    return any(getattr(perms, p, False) for p in LEVEL_PERMS)

def xp_for_level(level):
    return 50 * (level ** 2)  # Simple quadratic XP curve

class LevelingCog(commands.Cog):
    @commands.hybrid_command(name="rank", description="Show your or another user's level and XP.")
    async def rank(self, ctx, member: discord.Member = None):
        member = member or ctx.author
        guild_id = ctx.guild.id
        user_id = member.id
        level = self.user_level.get(guild_id, {}).get(user_id, 1)
        xp = self.user_xp.get(guild_id, {}).get(user_id, 0)
        prestige = self.user_prestige.get(guild_id, {}).get(user_id, 0)
        user_class = self.user_class.get(guild_id, {}).get(user_id, "None")
        next_level_xp = self.xp_for_level(level + 1)
        embed = discord.Embed(title=f"{member.display_name}'s Rank", color=discord.Color.blurple())
        embed.add_field(name="Level", value=str(level))
        embed.add_field(name="XP", value=f"{xp} / {next_level_xp}")
        embed.add_field(name="Class", value=user_class)
        embed.add_field(name="Prestige", value=str(prestige))
        embed.set_thumbnail(url=member.display_avatar.url)
        await ctx.send(embed=embed)

    @commands.hybrid_command(name="leaderboard", description="Show the top users by level.")
    async def leaderboard(self, ctx):
        guild_id = ctx.guild.id
        levels = self.user_level.get(guild_id, {})
        if not levels:
            await ctx.send("No users have leveled up yet.")
            return
        # Sort by level, then XP
        xp_map = self.user_xp.get(guild_id, {})
        prestige_map = self.user_prestige.get(guild_id, {})
        leaderboard = sorted(levels.items(), key=lambda x: (levels[x[0]], xp_map.get(x[0], 0), prestige_map.get(x[0], 0)), reverse=True)
        embed = discord.Embed(title="Leaderboard", color=discord.Color.gold())
        for i, (user_id, lvl) in enumerate(leaderboard[:10], 1):
            user = ctx.guild.get_member(user_id)
            name = user.display_name if user else f"User {user_id}"
            xp = xp_map.get(user_id, 0)
            prestige = prestige_map.get(user_id, 0)
            embed.add_field(name=f"#{i} {name}", value=f"Level: {lvl} | XP: {xp} | Prestige: {prestige}", inline=False)
        await ctx.send(embed=embed)

    def __init__(self, bot):
        self.bot = bot
        self.user_xp = {}  # {guild_id: {user_id: xp}}
        self.user_level = {}  # {guild_id: {user_id: level}}
        self.user_class = {}  # {guild_id: {user_id: class}}
        self.user_prestige = {}  # {guild_id: {user_id: prestige_points}}
        self.level_roles = {}  # {guild_id: {level: role_id}}
        self.level_channel = {}  # {guild_id: channel_id}
        self.level_message = {}  # {guild_id: message}
        self.level_ping = {}  # {guild_id: bool}

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot or not message.guild:
            return
        guild_id = message.guild.id
        user_id = message.author.id
        self.user_xp.setdefault(guild_id, {})
        self.user_level.setdefault(guild_id, {})
        self.user_class.setdefault(guild_id, {})
        self.user_prestige.setdefault(guild_id, {})
        xp = self.user_xp[guild_id].get(user_id, 0)
        level = self.user_level[guild_id].get(user_id, 1)
        user_class = self.user_class[guild_id].get(user_id, None)
        prestige = self.user_prestige[guild_id].get(user_id, 0)

        # --- XP Gain Logic ---
        # Early levels: 5-15 XP, 1 min cooldown (not implemented: cooldown per user for brevity)
        if level <= 10:
            gained = random.randint(5, 15)
        elif level < 150:
            gained = int((level ** 2) * 0.5 + random.randint(5, 10))
        else:
            gained = int((level ** 2) * 1.5 + random.randint(10, 30))

        # Quality-based XP: reactions, replies, creative channels, etc.
        # (Handled in separate listeners below)

        # Class bonus
        if user_class == "Socialist":
            gained = int(gained * 1.2)
        elif user_class == "Creator" and message.channel.name in ["art", "music", "memes"]:
            gained = int(gained * 1.5)
        elif user_class == "Strategist":
            # Placeholder: bonus for minigames, etc.
            pass

        xp += gained
        next_level_xp = self.xp_for_level(level + 1)
        leveled_up = False
        while xp >= next_level_xp:
            level += 1
            xp -= next_level_xp
            next_level_xp = self.xp_for_level(level + 1)
            leveled_up = True
        self.user_xp[guild_id][user_id] = xp
        self.user_level[guild_id][user_id] = level

        if leveled_up:
            # Prestige system
            if level in [50, 100, 150]:
                self.user_prestige[guild_id][user_id] = prestige + 1
                level = 1
                xp = 0
                await message.channel.send(f"{message.author.mention} has prestiged! Prestige points: {self.user_prestige[guild_id][user_id]}")
                self.user_level[guild_id][user_id] = level
                self.user_xp[guild_id][user_id] = xp
            # Assign role if set
            role_id = self.level_roles.get(guild_id, {}).get(level)
            if role_id:
                role = message.guild.get_role(role_id)
                if role:
                    await message.author.add_roles(role, reason="Level up reward")
            # Send level-up message
            channel_id = self.level_channel.get(guild_id)
            msg = self.level_message.get(guild_id, "{user} leveled up to {level}!")
            ping = self.level_ping.get(guild_id, False)
            if channel_id:
                channel = message.guild.get_channel(channel_id)
                if channel:
                    await channel.send(msg.format(user=message.author.mention if ping else message.author.display_name, level=level))

    def xp_for_level(self, level):
        # Early: linear, mid: quadratic, high: exponential
        if level <= 10:
            return 50 + (level - 1) * 25
        elif level < 150:
            return int((level ** 2) * 10)
        else:
            return int((level ** 2.5) * 12)

    @commands.Cog.listener()
    async def on_reaction_add(self, reaction, user):
        # Quality XP: 5+ reactions = +50 XP
        if user.bot or not reaction.message.guild:
            return
        if reaction.count >= 5:
            guild_id = reaction.message.guild.id
            user_id = reaction.message.author.id
            self.user_xp.setdefault(guild_id, {})
            self.user_xp[guild_id][user_id] = self.user_xp[guild_id].get(user_id, 0) + 50

    @commands.Cog.listener()
    async def on_thread_create(self, thread):
        # XP for starting a thread from a reply
        if thread.owner and thread.guild:
            guild_id = thread.guild.id
            user_id = thread.owner.id
            self.user_xp.setdefault(guild_id, {})
            self.user_xp[guild_id][user_id] = self.user_xp[guild_id].get(user_id, 0) + 30

    @commands.command(name="setclass")
    async def set_class(self, ctx, class_name: str):
        """Pick a leveling class: Socialist, Creator, Strategist."""
        valid = ["Socialist", "Creator", "Strategist"]
        if class_name not in valid:
            await ctx.send(f"Invalid class. Choose from: {', '.join(valid)}")
            return
        guild_id = ctx.guild.id
        user_id = ctx.author.id
        self.user_class.setdefault(guild_id, {})
        self.user_class[guild_id][user_id] = class_name
        await ctx.send(f"{ctx.author.mention} is now a {class_name}!")





# ---- FILE: villicus\bot\lock_cog.py ----

# bot/lock_cog.py
import discord
from discord.ext import commands
from datetime import timedelta

class LockCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="lock", description="Lock a channel.")
    @commands.has_guild_permissions(manage_channels=True)
    async def lock(self, ctx, channel: discord.TextChannel = None, duration: str = None):
        channel = channel or ctx.channel
        overwrite = channel.overwrites_for(ctx.guild.default_role)
        overwrite.send_messages = False
        await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)
        await ctx.send(f"{channel.mention} locked.")
        if duration:
            seconds = self.parse_time(duration)
            if seconds:
                await discord.utils.sleep_until(discord.utils.utcnow() + timedelta(seconds=seconds))
                overwrite.send_messages = None
                await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)
                await ctx.send(f"{channel.mention} unlocked (auto).")

    @commands.hybrid_command(name="unlock", description="Unlock a channel.")
    @commands.has_guild_permissions(manage_channels=True)
    async def unlock(self, ctx, channel: discord.TextChannel = None):
        channel = channel or ctx.channel
        overwrite = channel.overwrites_for(ctx.guild.default_role)
        overwrite.send_messages = None
        await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)
        await ctx.send(f"{channel.mention} unlocked.")

    @commands.hybrid_command(name="serverlock", description="Lock all text channels for @everyone (emergency).")
    @commands.has_guild_permissions(administrator=True)
    async def serverlock(self, ctx):
        guild = ctx.guild
        backup = {}
        for channel in guild.text_channels:
            try:
                prev = channel.overwrites_for(guild.default_role).send_messages
                backup[str(channel.id)] = None if prev is None else bool(prev)
                ow = channel.overwrites_for(guild.default_role)
                ow.send_messages = False
                await channel.set_permissions(guild.default_role, overwrite=ow)
            except Exception:
                continue
        # persist backup
        from core import db as core_db
        db = core_db.DB()
        await db.connect()
        await db.set_guild_setting(guild.id, 'server_lock_backup', json.dumps(backup))
        await db.set_guild_setting(guild.id, 'server_locked', '1')
        await ctx.send("Server locked: @everyone send_messages disabled on text channels.")

    @commands.hybrid_command(name="serverunlock", description="Restore channels after serverlock.")
    @commands.has_guild_permissions(administrator=True)
    async def serverunlock(self, ctx):
        guild = ctx.guild
        from core import db as core_db
        db = core_db.DB()
        await db.connect()
        raw = await db.get_guild_setting(guild.id, 'server_lock_backup')
        if not raw:
            await ctx.send("No backup found. Use manual unlock if needed.")
            return
        try:
            backup = json.loads(raw)
        except Exception:
            backup = {}
        for cid, val in backup.items():
            try:
                ch = guild.get_channel(int(cid))
                if not ch:
                    continue
                ow = ch.overwrites_for(guild.default_role)
                ow.send_messages = None if val is None else bool(val)
                await ch.set_permissions(guild.default_role, overwrite=ow)
            except Exception:
                continue
        await db.delete_guild_setting(guild.id, 'server_lock_backup')
        await db.set_guild_setting(guild.id, 'server_locked', None)
        await ctx.send("Server unlocked and backups restored.")

    def parse_time(self, time_str):
        try:
            units = {"s": 1, "m": 60, "h": 3600, "d": 86400}
            if time_str.isdigit():
                return int(time_str)
            num = int(''.join(filter(str.isdigit, time_str)))
            unit = ''.join(filter(str.isalpha, time_str)).lower()
            return num * units.get(unit, 1)
        except Exception:
            return None

def setup(bot):
    bot.add_cog(LockCog(bot))




# ---- FILE: villicus\bot\mod_commands_cog.py ----

# bot/mod_commands_cog.py
import discord
from discord.ext import commands
from datetime import timedelta, datetime
import asyncio
from .mod_manager import ModManager

MOD_PERMS = ["manage_guild", "manage_channels", "administrator", "manage_webhooks"]

async def has_mod_perms(ctx):
    perms = ctx.author.guild_permissions
    return any(getattr(perms, p, False) for p in MOD_PERMS)


class ModCommandsCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        # Initialize persistent moderation manager
        try:
            self.mod_manager = ModManager(bot)
        except Exception:
            self.mod_manager = None
        # Required staff levels per command (default high for unknown commands)
        self.REQUIRED_LEVELS = {
            "warn": 1,
            "mute": 2,
            "unmute": 2,
            "kick": 3,
            "softban": 4,
            "tempban": 4,
            "ban": 5,
            "unban": 4,
            "purge": 2,
            "clean": 2,
        }
    async def cog_check(self, ctx):
        # Allow guild moderators (manage_guild etc.) OR staff roles configured via ModManager
        try:
            if await has_mod_perms(ctx):
                return True
        except Exception:
            pass
        # Fallback to staff role level checks
        try:
            if not self.mod_manager:
                return False
            # Check for guild override first
            required = self.REQUIRED_LEVELS.get(ctx.command.name, 10)
            try:
                override = await self.mod_manager.get_command_required_level(ctx.guild.id, ctx.command.name)
                if override is not None:
                    required = override
            except Exception:
                pass
            level = await self.mod_manager.get_member_staff_level(ctx.guild.id, ctx.author)
            if level >= required:
                return True
            # Inform user
            try:
                await self._send_error(ctx, f"Insufficient staff level. Required level: {required}.")
            except Exception:
                pass
            return False
        except Exception:
            return False

    def _vip_footer(self, embed):
        embed.set_footer(text="Villicus | The Ultimate VIP Bot Experience ✨")
        embed.set_thumbnail(url="https://cdn.discordapp.com/icons/1171111111111111111/villicus_vip.png")
        return embed

    @commands.hybrid_command(name="unban", description="Unban a user by ID or name#discrim.")
    @discord.app_commands.describe(user="User ID or username#discrim to unban")
    @commands.has_guild_permissions(ban_members=True)
    async def unban(self, ctx, *, user: str):
        try:
            bans = await ctx.guild.bans()
            user_obj = None
            for ban_entry in bans:
                if (
                    str(ban_entry.user.id) == user
                    or f"{ban_entry.user.name}#{ban_entry.user.discriminator}" == user
                ):
                    user_obj = ban_entry.user
                    break
            if not user_obj:
                await self._send_error(ctx, "User not found in ban list.")
                return
            await ctx.guild.unban(user_obj)
            # Remove any persistent punishments (tempbans)
            try:
                if hasattr(self, 'mod_manager') and self.mod_manager:
                    await self.mod_manager.remove_punishments_for(ctx.guild.id, user_obj.id, actions=["tempban", "ban"])
            except Exception:
                pass
            embed = self._mod_embed("Unban", user_obj, "Unbanned by moderator.")
            embed = self._vip_footer(embed)
            await ctx.send(embed=embed)
            # Immediate audit log
            try:
                actionlog = self.bot.get_cog("ActionLogCog")
                if actionlog:
                    user_display = f"{user_obj} ({user_obj.id})"
                    mod_display = f"{ctx.author} ({ctx.author.id})"
                    thumb = None
                    try:
                        thumb = user_obj.display_avatar.url
                    except Exception:
                        thumb = None
                    await actionlog.send_action_log(ctx.guild.id, "unban", user_display, mod_display, "Unbanned by moderator", None, thumb)
            except Exception:
                pass
        except Exception as e:
            await self._send_error(ctx, f"Unban failed: {e}")

    @commands.hybrid_command(name="unmute", description="Unmute a user (remove timeout).")
    @discord.app_commands.describe(member="Member to unmute")
    @commands.has_guild_permissions(moderate_members=True)
    async def unmute(self, ctx, member: discord.Member):
        try:
            await member.edit(timeout=None)
            # Remove any persistent mute entries
            try:
                if hasattr(self, 'mod_manager') and self.mod_manager:
                    await self.mod_manager.remove_punishments_for(ctx.guild.id, member.id, actions=["mute"])
            except Exception:
                pass
            embed = self._mod_embed("Unmute", member, "Unmuted by moderator.")
            embed = self._vip_footer(embed)
            await ctx.send(embed=embed)
            # Immediate audit log
            try:
                actionlog = self.bot.get_cog("ActionLogCog")
                if actionlog:
                    user_display = f"{member} ({member.id})"
                    mod_display = f"{ctx.author} ({ctx.author.id})"
                    thumb = None
                    try:
                        thumb = member.display_avatar.url
                    except Exception:
                        thumb = None
                    await actionlog.send_action_log(ctx.guild.id, "unmute", user_display, mod_display, "Unmuted by moderator", None, thumb)
            except Exception:
                pass
        except Exception as e:
            await self._send_error(ctx, f"Unmute failed: {e}")


    @commands.hybrid_command(name="ban", description="Ban a user from the server.")
    @discord.app_commands.describe(member="Member to ban", reason="Reason for ban")
    @commands.has_guild_permissions(ban_members=True)
    async def ban(self, ctx, member: discord.Member, *, reason: str = "No reason provided"):
        try:
            if member == ctx.author:
                await self._send_error(ctx, "You cannot ban yourself.")
                return
            if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
                await self._send_error(ctx, "You cannot ban someone with an equal or higher role.")
                return
            await member.ban(reason=reason)
            # Record permanent ban in DB for audit
            try:
                    if hasattr(self, 'mod_manager') and self.mod_manager:
                        await self.mod_manager.record_decision(ctx.guild.id, member.id, "ban", reason=reason, moderator_id=ctx.author.id, metadata={'manual': True})
            except Exception:
                pass
            await self._dm_action(member, "Ban", reason, ctx=ctx)
            embed = self._mod_embed("Ban", member, reason)
            embed = self._vip_footer(embed)
            await ctx.send(embed=embed)
            # Immediate audit log
            try:
                actionlog = self.bot.get_cog("ActionLogCog")
                if actionlog:
                    user_display = f"{member} ({member.id})"
                    mod_display = f"{ctx.author} ({ctx.author.id})"
                    thumb = None
                    try:
                        thumb = member.display_avatar.url
                    except Exception:
                        thumb = None
                    await actionlog.send_action_log(ctx.guild.id, "ban", user_display, mod_display, reason, None, thumb)
            except Exception:
                pass
        except discord.Forbidden:
            await self._send_error(ctx, "I do not have permission to ban this user.")
        except Exception as e:
            await self._send_error(ctx, f"Ban failed: {e}")


    @commands.hybrid_command(name="kick", description="Kick a user from the server.")
    @discord.app_commands.describe(member="Member to kick", reason="Reason for kick")
    @commands.has_guild_permissions(kick_members=True)
    async def kick(self, ctx, member: discord.Member, *, reason: str = "No reason provided"):
        try:
            if member == ctx.author:
                await self._send_error(ctx, "You cannot kick yourself.")
                return
            if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
                await self._send_error(ctx, "You cannot kick someone with an equal or higher role.")
                return
            await member.kick(reason=reason)
            await self._dm_action(member, "Kick", reason, ctx=ctx)
            embed = self._mod_embed("Kick", member, reason)
            embed = self._vip_footer(embed)
            await ctx.send(embed=embed)
            # Immediate audit log
            try:
                actionlog = self.bot.get_cog("ActionLogCog")
                if actionlog:
                    user_display = f"{member} ({member.id})"
                    mod_display = f"{ctx.author} ({ctx.author.id})"
                    thumb = None
                    try:
                        thumb = member.display_avatar.url
                    except Exception:
                        thumb = None
                    await actionlog.send_action_log(ctx.guild.id, "kick", user_display, mod_display, reason, None, thumb)
            except Exception:
                pass
        except discord.Forbidden:
            await self._send_error(ctx, "I do not have permission to kick this user.")
        except Exception as e:
            await self._send_error(ctx, f"Kick failed: {e}")


    @commands.hybrid_command(name="warn", description="Warn a user.")
    @discord.app_commands.describe(member="Member to warn", reason="Reason for warning", duration="How long the warn should last (e.g. 30d)")
    @commands.has_guild_permissions(moderate_members=True)
    async def warn(self, ctx, member: discord.Member, reason: str, duration: str = "30d"):
        try:
            if member == ctx.author:
                await self._send_error(ctx, "You cannot warn yourself.")
                return
            await self._dm_action(member, "Warn", reason, duration, ctx=ctx)
            # Persist warn (optionally with expiry)
            try:
                    if hasattr(self, 'mod_manager') and self.mod_manager:
                        seconds = self._parse_duration(duration)
                        expires_at = int(__import__('time').time()) + seconds if seconds else None
                        await self.mod_manager.record_decision(ctx.guild.id, member.id, "warn", reason=reason, moderator_id=ctx.author.id, expires_at=expires_at, metadata={'manual': True})
                    # After adding a warn, check thresholds and auto-apply punishments
                    try:
                        await self.mod_manager.check_warns_and_apply(ctx.guild.id, member.id)
                    except Exception:
                        pass
            except Exception:
                pass
            embed = self._mod_embed("Warn", member, reason, duration)
            embed = self._vip_footer(embed)
            await ctx.send(embed=embed)
            # Immediate audit log for warn
            try:
                actionlog = self.bot.get_cog("ActionLogCog")
                if actionlog:
                    user_display = f"{member} ({member.id})"
                    mod_display = f"{ctx.author} ({ctx.author.id})"
                    thumb = None
                    try:
                        thumb = member.display_avatar.url
                    except Exception:
                        thumb = None
                    await actionlog.send_action_log(ctx.guild.id, "warn", user_display, mod_display, reason, duration, thumb)
            except Exception:
                pass
        except Exception as e:
            await self._send_error(ctx, f"Warn failed: {e}")


    @commands.hybrid_command(name="mute", description="Mute a user for a duration.")
    @discord.app_commands.describe(member="Member to mute", duration="Duration (e.g. 10m, 2h, 1d)", reason="Reason for mute")
    @commands.has_guild_permissions(moderate_members=True)
    async def mute(self, ctx, member: discord.Member, duration: str, *, reason: str = "No reason provided"):
        try:
            if member == ctx.author:
                await self._send_error(ctx, "You cannot mute yourself.")
                return
            # Use Discord's timeout feature if available
            seconds = self._parse_duration(duration)
            if seconds is None:
                await self._send_error(ctx, "Invalid duration format. Use e.g. 10m, 2h, 1d.")
                return
            until = discord.utils.utcnow() + timedelta(seconds=seconds)
            await member.timeout(until, reason=reason)
            # Persist mute for automatic unmute later
            try:
                if hasattr(self, 'mod_manager') and self.mod_manager:
                    expires_at = int(__import__('time').time()) + seconds
                    await self.mod_manager.record_decision(ctx.guild.id, member.id, "mute", reason=reason, moderator_id=ctx.author.id, expires_at=expires_at, metadata={'manual': True})
            except Exception:
                pass
            await self._dm_action(member, "Mute", reason, duration, ctx=ctx)
            embed = self._mod_embed("Mute", member, reason, duration)
            embed = self._vip_footer(embed)
            await ctx.send(embed=embed)
            # Immediate audit log for mute
            try:
                actionlog = self.bot.get_cog("ActionLogCog")
                if actionlog:
                    user_display = f"{member} ({member.id})"
                    mod_display = f"{ctx.author} ({ctx.author.id})"
                    thumb = None
                    try:
                        thumb = member.display_avatar.url
                    except Exception:
                        thumb = None
                    await actionlog.send_action_log(ctx.guild.id, "mute", user_display, mod_display, reason, duration, thumb)
            except Exception:
                pass
        except discord.Forbidden:
            await self._send_error(ctx, "I do not have permission to mute this user.")
        except Exception as e:
            await self._send_error(ctx, f"Mute failed: {e}")


    @commands.hybrid_command(name="tempban", description="Temporarily ban a user.")
    @discord.app_commands.describe(member="Member to tempban", duration="Duration (e.g. 7d)", reason="Reason for tempban")
    @commands.has_guild_permissions(ban_members=True)
    async def tempban(self, ctx, member: discord.Member, duration: str, *, reason: str = "No reason provided"):
        try:
            if member == ctx.author:
                await self._send_error(ctx, "You cannot tempban yourself.")
                return
            if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
                await self._send_error(ctx, "You cannot tempban someone with an equal or higher role.")
                return
            await member.ban(reason=reason)
            await self._dm_action(member, "Tempban", reason, duration, ctx=ctx)
            embed = self._mod_embed("Tempban", member, reason, duration)
            embed = self._vip_footer(embed)
            await ctx.send(embed=embed)
            # Persist tempban for automatic unban later
            try:
                if hasattr(self, 'mod_manager') and self.mod_manager:
                    seconds = self._parse_duration(duration)
                    expires_at = int(__import__('time').time()) + seconds if seconds else None
                    await self.mod_manager.record_decision(ctx.guild.id, member.id, "tempban", reason=reason, moderator_id=ctx.author.id, expires_at=expires_at, metadata={'manual': True})
            except Exception:
                pass
            # Immediate audit log for tempban
            try:
                actionlog = self.bot.get_cog("ActionLogCog")
                if actionlog:
                    user_display = f"{member} ({member.id})"
                    mod_display = f"{ctx.author} ({ctx.author.id})"
                    thumb = None
                    try:
                        thumb = member.display_avatar.url
                    except Exception:
                        thumb = None
                    await actionlog.send_action_log(ctx.guild.id, "tempban", user_display, mod_display, reason, duration, thumb)
            except Exception:
                pass
        except discord.Forbidden:
            await self._send_error(ctx, "I do not have permission to ban this user.")
        except Exception as e:
            await self._send_error(ctx, f"Tempban failed: {e}")


    @commands.hybrid_command(name="softban", description="Softban a user (ban and unban to delete messages).")
    @discord.app_commands.describe(member="Member to softban", reason="Reason for softban")
    @commands.has_guild_permissions(ban_members=True)
    async def softban(self, ctx, member: discord.Member, *, reason: str = "No reason provided"):
        try:
            if member == ctx.author:
                await self._send_error(ctx, "You cannot softban yourself.")
                return
            if member.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:
                await self._send_error(ctx, "You cannot softban someone with an equal or higher role.")
                return
            await member.ban(reason=reason)
            await member.unban()
            await self._dm_action(member, "Softban", reason, ctx=ctx)
            embed = self._mod_embed("Softban", member, reason)
            embed = self._vip_footer(embed)
            await ctx.send(embed=embed)
            # Immediate audit log for softban
            try:
                actionlog = self.bot.get_cog("ActionLogCog")
                if actionlog:
                    user_display = f"{member} ({member.id})"
                    mod_display = f"{ctx.author} ({ctx.author.id})"
                    thumb = None
                    try:
                        thumb = member.display_avatar.url
                    except Exception:
                        thumb = None
                    await actionlog.send_action_log(ctx.guild.id, "softban", user_display, mod_display, reason, None, thumb)
            except Exception:
                pass
        except discord.Forbidden:
            await self._send_error(ctx, "I do not have permission to ban/unban this user.")
        except Exception as e:
            await self._send_error(ctx, f"Softban failed: {e}")
        async def _send_error(self, ctx, message):
            embed = discord.Embed(title="❌ VIP Error", description=message, color=discord.Color.red())
            embed = self._vip_footer(embed)
            if hasattr(ctx, "interaction") and ctx.interaction:
                try:
                    await ctx.interaction.response.send_message(embed=embed, ephemeral=True)
                except Exception:
                    await ctx.send(embed=embed)
            else:
                await ctx.send(embed=embed)
    def _parse_duration(self, duration):
        try:
            units = {"s": 1, "m": 60, "h": 3600, "d": 86400}
            if duration.isdigit():
                return int(duration)
            num = int(''.join(filter(str.isdigit, duration)))
            unit = ''.join(filter(str.isalpha, duration)).lower()
            return num * units.get(unit, 1)
        except Exception:
            return None


    async def _dm_action(self, member, action, reason, duration=None, ctx=None):
        try:
            embed = discord.Embed(
                title=f"You are being {action.lower()}ed in {member.guild.name}",
                description=f"Reason: {reason}",
                color=discord.Color.red()
            )
            if duration:
                embed.add_field(name="Duration", value=duration, inline=False)
            # Add appeal information if configured
            try:
                appeal_type = None
                appeal_value = None
                if ctx and ctx.bot:
                    config = ctx.bot.get_cog('ConfigCog')
                    if config and getattr(config, 'mod_manager', None):
                        appeal_type = await config.mod_manager.get_guild_setting(ctx.guild.id, 'appeal_type')
                        appeal_value = await config.mod_manager.get_guild_setting(ctx.guild.id, 'appeal_value')
                    else:
                        appeals_cog = ctx.bot.get_cog('AppealsCog')
                        if appeals_cog and hasattr(appeals_cog, 'appeal_url'):
                            appeal_type = 'url'
                            appeal_value = appeals_cog.appeal_url
                if appeal_type in ('url', 'invite') and appeal_value:
                    embed.add_field(name="Appeal", value=f"[Appeal Here]({appeal_value})", inline=False)
            except Exception:
                pass
            # Add invite link if possible
            invite = None
            if ctx and ctx.guild:
                try:
                    invites = await ctx.guild.invites()
                    if invites:
                        invite = invites[0].url
                except Exception:
                    pass
            if invite:
                embed.add_field(name="Rejoin", value=invite, inline=False)
            await member.send(embed=embed)
        except Exception:
            pass

    def _mod_embed(self, action, member, reason, duration=None):
        embed = discord.Embed(
            title=f"{action} • VIP Moderation",
            color=discord.Color.from_rgb(255, 215, 0)
        )
        embed.add_field(name="User", value=member.mention)
        embed.add_field(name="Reason", value=reason)
        if duration:
            embed.add_field(name="Duration", value=duration)
        embed.timestamp = datetime.utcnow()
        embed.set_thumbnail(url=member.display_avatar.url if hasattr(member, 'display_avatar') else None)
        return embed




# ---- FILE: villicus\bot\mod_manager.py ----

import asyncio
import aiosqlite
import logging
import time
import json
import discord
from datetime import datetime, timezone
from pathlib import Path
from core import db as core_db

log = logging.getLogger("mod_manager")


class ModManager:
    def __init__(self, bot, db_path: str | Path = None, poll_interval: int = 30):
        self.bot = bot
        self.db = core_db.DB(path=db_path)
        self.poll_interval = poll_interval
        self._task = None
        asyncio.get_event_loop().create_task(self._startup())

    async def _startup(self):
        await core_db.init_db(self.db.path)
        await self.db.connect()
        self._task = asyncio.create_task(self._expiry_loop())
        log.info("ModManager started and DB connected.")

    async def add_punishment(self, guild_id: int, user_id: int, action: str, reason: str | None = None,
                             moderator_id: int | None = None, expires_at: int | None = None, metadata: dict | None = None):
        now = int(time.time())
        meta_json = json.dumps(metadata) if metadata else None
        await self.db.execute(
            "INSERT INTO punishments (guild_id, user_id, action, reason, moderator_id, created_at, expires_at, metadata) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
            [guild_id, user_id, action, reason, moderator_id, now, expires_at, meta_json]
        )
        # Persist an action log entry as well for audit
        try:
            meta_str = json.dumps(metadata) if metadata else None
            await self.db.insert_action_log(guild_id, action, target=str(user_id), moderator_id=moderator_id, reason=reason, metadata=meta_str)
        except Exception:
            pass
        # Log action to configured audit channel if ActionLogCog is present
        try:
            actionlog = self.bot.get_cog("ActionLogCog")
            if actionlog:
                user_display = None
                try:
                    user = self.bot.get_user(user_id) or await self.bot.fetch_user(user_id)
                    user_display = f"{user} ({user.id})"
                    thumbnail = getattr(user, "display_avatar", None)
                    thumb_url = thumbnail.url if thumbnail else None
                except Exception:
                    user_display = str(user_id)
                    thumb_url = None
                moderator_display = None
                if moderator_id:
                    try:
                        mod = self.bot.get_user(moderator_id) or await self.bot.fetch_user(moderator_id)
                        moderator_display = f"{mod} ({mod.id})"
                    except Exception:
                        moderator_display = str(moderator_id)
                duration = None
                if expires_at:
                    duration = f"Until {datetime.fromtimestamp(expires_at).isoformat()}"
                await actionlog.send_action_log(guild_id, action, user_display, moderator_display, reason, duration, thumb_url)
        except Exception:
            pass

    # Guild settings and staff role helpers
    async def set_guild_setting(self, guild_id: int, key: str, value: str | None):
        await self.db.execute("DELETE FROM guild_settings WHERE guild_id = ? AND key = ?", [guild_id, key])
        if value is not None:
            await self.db.execute("INSERT INTO guild_settings (guild_id, key, value) VALUES (?, ?, ?)", [guild_id, key, value])

    async def get_guild_setting(self, guild_id: int, key: str):
        row = await self.db.fetchone("SELECT value FROM guild_settings WHERE guild_id = ? AND key = ? LIMIT 1", [guild_id, key])
        return row[0] if row else None

    async def get_staff_roles(self, guild_id: int) -> dict:
        raw = await self.get_guild_setting(guild_id, "staff_roles")
        if not raw:
            return {}
        try:
            return json.loads(raw)
        except Exception:
            return {}

    async def add_staff_role(self, guild_id: int, role_id: int, level: int):
        roles = await self.get_staff_roles(guild_id)
        roles[str(role_id)] = int(level)
        await self.set_guild_setting(guild_id, "staff_roles", json.dumps(roles))

    async def remove_staff_role(self, guild_id: int, role_id: int):
        roles = await self.get_staff_roles(guild_id)
        roles.pop(str(role_id), None)
        await self.set_guild_setting(guild_id, "staff_roles", json.dumps(roles))

    async def get_member_staff_level(self, guild_id: int, member) -> int:
        roles = await self.get_staff_roles(guild_id)
        if not roles:
            return 0
        try:
            best = 0
            for r in member.roles:
                lvl = roles.get(str(r.id))
                if lvl and int(lvl) > best:
                    best = int(lvl)
            return best
        except Exception:
            return 0

    # Action logs retrieval
    async def get_action_logs(self, guild_id: int, limit: int = 200):
        try:
            rows = await self.db.get_action_logs(guild_id, limit=limit)
            out = []
            for r in rows:
                out.append({
                    'id': r['id'],
                    'action': r['action'],
                    'target': r['target'],
                    'moderator_id': r['moderator_id'],
                    'reason': r['reason'],
                    'created_at': r['created_at'],
                    'metadata': json.loads(r['metadata']) if r['metadata'] else None
                })
            return out
        except Exception:
            return []

    async def lazy_setup(self, guild_id: int):
        """
        Perform a non-destructive lazy setup: write recommended default settings into guild_settings.
        This is a safe fallback when creating channels/roles isn't desired by the host.
        If more advanced behavior is needed (creating roles/channels), override this in a derived implementation.
        """
        try:
            defaults = {
                'automod': 'true',
                'antinuke': 'false',
                'welcome': 'true',
                'tickets': 'true',
                'muted_role': '',
                'quarantined_role': '',
                'warns_to_punish': '3',
                'warn_punish_action': 'mute'
            }
            for k, v in defaults.items():
                await self.set_guild_setting(guild_id, k, v)
            # return a summary
            return {'ok': True, 'applied': defaults}
        except Exception as e:
            return {'ok': False, 'error': str(e)}

    # Command-level required staff levels
    async def set_command_required_level(self, guild_id: int, command_name: str, level: int | None):
        key = f"cmd_level:{command_name}"
        if level is None:
            await self.set_guild_setting(guild_id, key, None)
        else:
            await self.set_guild_setting(guild_id, key, str(int(level)))

    async def get_command_required_level(self, guild_id: int, command_name: str) -> int | None:
        key = f"cmd_level:{command_name}"
        raw = await self.get_guild_setting(guild_id, key)
        try:
            return int(raw) if raw is not None else None
        except Exception:
            return None

    async def check_warns_and_apply(self, guild_id: int, user_id: int):
        """Check configured warn threshold and apply configured punishment if threshold met."""
        try:
            raw = await self.get_guild_setting(guild_id, "warns_to_punish")
            if not raw:
                return False
            try:
                threshold = int(raw)
            except Exception:
                return False
            now = int(time.time())
            row = await self.db.fetchone(
                "SELECT COUNT(*) as cnt FROM punishments WHERE guild_id = ? AND user_id = ? AND action = 'warn' AND (expires_at IS NULL OR expires_at > ?)",
                [guild_id, user_id, now]
            )
            cnt = int(row[0]) if row and row[0] is not None else 0
            if cnt < threshold:
                return False
            action = await self.get_guild_setting(guild_id, "warn_punish_action") or "mute"
            # Determine default duration (seconds) from settings or default to 1 day for mutes/tempbans
            dur_raw = await self.get_guild_setting(guild_id, "warn_punish_duration")
            try:
                duration_seconds = int(dur_raw) if dur_raw else 86400
            except Exception:
                duration_seconds = 86400
            # Apply punishment: try to perform server-side action, and persist it
            try:
                # Try to perform the actual Discord action
                await self._apply_action(guild_id, user_id, action, moderator_id=None, duration_seconds=duration_seconds)
            except Exception:
                pass
            # Create an explainable record for the auto-applied punishment and notify user
            explanation = f"Auto-applied after {cnt} warns (threshold {threshold}). Action: {action}."
            metadata = {"auto_applied": True, "warn_count": cnt, "threshold": threshold, "explanation": explanation}
            await self.record_decision(guild_id, user_id, action, reason=f"Auto-applied after {cnt} warns", moderator_id=None, expires_at=(int(time.time()) + duration_seconds if action in ("mute", "tempban") else None), metadata=metadata)
            return True
        except Exception:
            return False

    async def remove_punishment(self, punish_id: int):
        await self.db.execute("DELETE FROM punishments WHERE id = ?", [punish_id])

    async def remove_punishments_for(self, guild_id: int, user_id: int, actions: list | None = None):
        if actions:
            placeholders = ",".join(["?" for _ in actions])
            params = [guild_id, user_id] + actions
            await self.db.execute(f"DELETE FROM punishments WHERE guild_id = ? AND user_id = ? AND action IN ({placeholders})", params)
        else:
            await self.db.execute("DELETE FROM punishments WHERE guild_id = ? AND user_id = ?", [guild_id, user_id])

    async def _expiry_loop(self):
        while True:
            try:
                now = int(time.time())
                rows = await self.db.fetchall("SELECT * FROM punishments WHERE expires_at IS NOT NULL AND expires_at <= ?", [now])
                for row in rows:
                    await self._handle_expiration(row)
            except Exception as e:
                log.exception("Error in expiry loop: %s", e)
            await asyncio.sleep(self.poll_interval)

    async def _ensure_muted_role(self, guild: 'discord.Guild'):
        """Ensure a muted role exists for the guild and that channel overwrites deny speaking/sending.
        Returns the Role object or None on failure.
        """
        try:
            # Check stored muted role id
            raw = await self.get_guild_setting(guild.id, "muted_role")
            role = None
            if raw:
                try:
                    role = guild.get_role(int(raw))
                except Exception:
                    role = None
            if role is None:
                # create a role named 'Muted' (unique name per guild may be fine)
                try:
                    role = await guild.create_role(name="Muted", reason="Create muted role for Villicus", permissions=discord.Permissions.none())
                    await self.set_guild_setting(guild.id, "muted_role", str(role.id))
                except Exception:
                    return None
            # Ensure overwrites on all text and voice channels
            for channel in guild.channels:
                try:
                    # build a conservative deny overwrite
                    deny = discord.PermissionOverwrite(send_messages=False, add_reactions=False, speak=False, connect=False)
                    # For text channels also deny thread creation/send messages in threads if attribute present
                    await channel.set_permissions(role, overwrite=deny)
                except Exception:
                    # ignore channels where we can't set perms
                    continue
            return role
        except Exception:
            return None

    async def _handle_expiration(self, row):
        guild = self.bot.get_guild(row["guild_id"]) or None
        if not guild:
            await self.remove_punishment(row["id"])
            return
        user_id = row["user_id"]
        action = row["action"]
        try:
            if action == "mute":
                member = guild.get_member(user_id)
                if member:
                    try:
                        # try to clear timeout (Guild timeout API)
                        try:
                            await member.edit(timeout=None)
                        except Exception:
                            # fallback: remove muted role if present
                            muted_role_id = await self.get_guild_setting(guild.id, "muted_role")
                            if muted_role_id:
                                try:
                                    role = guild.get_role(int(muted_role_id))
                                    if role and role in member.roles:
                                        await member.remove_roles(role, reason="Mute expired")
                                except Exception:
                                    pass
                    except Exception:
                        pass
            elif action == "tempban":
                try:
                    user = await self.bot.fetch_user(user_id)
                    await guild.unban(user)
                except Exception:
                    pass
            # For other actions like 'ghost' the server-specific reversal should be implemented elsewhere
        finally:
            await self.remove_punishment(row["id"])

    async def _apply_action(self, guild_id: int, user_id: int, action: str, moderator_id: int | None = None, duration_seconds: int | None = None):
        """Attempt to perform the Discord API action for the given punishment."""
        guild = None
        try:
            guild = self.bot.get_guild(guild_id)
        except Exception:
            guild = None
        if not guild:
            return False
        try:
            if action == "mute":
                member = guild.get_member(user_id)
                if member:
                    until = None
                    if duration_seconds:
                        until = datetime.fromtimestamp(int(time.time() + duration_seconds), timezone.utc)
                    try:
                        await member.timeout(until, reason="Auto-applied mute from warn threshold")
                    except Exception:
                        try:
                            await member.edit(timeout=until)
                        except Exception:
                            pass
                    # If timeout API unsupported or failed, apply muted-role fallback
                    if not getattr(member, 'timed_out', False):
                        try:
                            # ensure muted role exists and assign
                            role = await self._ensure_muted_role(guild)
                            if role:
                                await member.add_roles(role, reason="Fallback muted-role applied")
                        except Exception:
                            pass
                    # persist with expiry
                    expires_at = int(time.time()) + duration_seconds if duration_seconds else None
                    await self.add_punishment(guild_id, user_id, "mute", reason="Auto-applied mute", moderator_id=moderator_id, expires_at=expires_at)
                    return True
            elif action == "tempban":
                # ban for duration, schedule unban via DB expiry
                try:
                    user = await self.bot.fetch_user(user_id)
                    await guild.ban(user, reason="Auto tempban from warn threshold")
                except Exception:
                    pass
                expires_at = int(time.time()) + duration_seconds if duration_seconds else None
                await self.add_punishment(guild_id, user_id, "tempban", reason="Auto tempban", moderator_id=moderator_id, expires_at=expires_at)
                return True
            elif action == "ban":
                try:
                    user = await self.bot.fetch_user(user_id)
                    await guild.ban(user, reason="Auto ban from warn threshold")
                except Exception:
                    pass
                await self.add_punishment(guild_id, user_id, "ban", reason="Auto ban", moderator_id=moderator_id)
                return True
            elif action == "kick":
                member = guild.get_member(user_id)
                if member:
                    try:
                        await member.kick(reason="Auto kick from warn threshold")
                    except Exception:
                        pass
                    await self.add_punishment(guild_id, user_id, "kick", reason="Auto kick", moderator_id=moderator_id)
                    return True
            elif action == "apply_mute_role":
                # Explicit action to apply muted role (fallback). Create or find muted role and add it.
                guild = self.bot.get_guild(guild_id)
                if not guild:
                    return False
                member = guild.get_member(user_id)
                role = await self._ensure_muted_role(guild)
                if member and role:
                    try:
                        await member.add_roles(role, reason="Muted role applied")
                        expires_at = int(time.time()) + duration_seconds if duration_seconds else None
                        await self.add_punishment(guild_id, user_id, "mute", reason="Muted role applied", moderator_id=moderator_id, expires_at=expires_at)
                        return True
                    except Exception:
                        return False
        except Exception:
            return False
        return False

    async def record_decision(self, guild_id: int, user_id: int, action: str, reason: str | None = None,
                              moderator_id: int | None = None, expires_at: int | None = None, metadata: dict | None = None):
        """Record a decision with structured metadata and notify the affected user with an explanation when possible.
        This centralizes explainability and audit logging for automatic or manual actions.
        """
        try:
            # Ensure metadata is a JSON-serializable dict
            meta = metadata.copy() if isinstance(metadata, dict) else {}
            if "created_by" not in meta:
                meta["created_by"] = moderator_id
            # Persist punishment
            await self.add_punishment(guild_id, user_id, action, reason=reason, moderator_id=moderator_id, expires_at=expires_at, metadata=meta)
            # Also insert a clear action log entry (add_punishment already logs, but ensure explanation presence)
            try:
                meta_str = json.dumps(meta) if meta else None
                await self.db.insert_action_log(guild_id, action, target=str(user_id), moderator_id=moderator_id, reason=reason, metadata=meta_str)
            except Exception:
                pass
            # Notify user with explanation if possible
            try:
                guild = self.bot.get_guild(guild_id)
                if guild:
                    user = await self.bot.fetch_user(user_id)
                    explanation = meta.get("explanation") if meta else None
                    if explanation:
                        try:
                            embed = discord.Embed(title=f"Action taken in {guild.name}", description=explanation, color=discord.Color.orange())
                            if reason:
                                embed.add_field(name="Reason", value=reason, inline=False)
                            embed.add_field(name="Action", value=action, inline=False)
                            embed.set_footer(text="You may appeal this action with /appeal if enabled.")
                            await user.send(embed=embed)
                        except Exception:
                            pass
            except Exception:
                pass

            # Create a staff review thread if the guild has a review channel configured
            try:
                review_chan_raw = await self.get_guild_setting(guild_id, 'auto_review_channel')
                if review_chan_raw:
                    try:
                        review_ch = guild.get_channel(int(review_chan_raw))
                    except Exception:
                        review_ch = None
                else:
                    review_ch = None
                if review_ch:
                    # attempt to fetch the punishment id we just inserted
                    try:
                        row = await self.db.fetchone("SELECT id FROM punishments WHERE guild_id = ? AND user_id = ? AND action = ? ORDER BY created_at DESC LIMIT 1", [guild_id, user_id, action])
                        punish_id = int(row['id']) if row else None
                    except Exception:
                        punish_id = None

                    # Build staff embed (use .format to avoid nested f-string parser edge-cases)
                    desc_text = meta.get('explanation') if meta and 'explanation' in meta else "Auto-applied {}".format(action)
                    staff_embed = discord.Embed(title="Review: auto-applied action", description=desc_text, color=discord.Color.blurple())
                    staff_embed.add_field(name="Target", value="<@{}> ({})".format(user_id, user_id), inline=False)
                    staff_embed.add_field(name="Action", value=action, inline=True)
                    if reason:
                        staff_embed.add_field(name="Reason", value=reason, inline=False)
                    if meta:
                        staff_embed.add_field(name="Metadata", value=json.dumps(meta)[:1000], inline=False)
                    try:
                        msg = await review_ch.send(embed=staff_embed)
                        view = self.ReviewActionView(self, guild_id, punish_id, user_id, action)
                        await msg.edit(view=view)
                        # create a thread for discussion
                        try:
                            thread = await msg.create_thread(name="Review {} - {}".format(action, user_id), auto_archive_duration=1440)
                            await thread.send("Staff review thread for action `{}` on <@{}>".format(action, user_id))
                        except Exception:
                            pass
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            pass

    class ReviewActionView(discord.ui.View):
        def __init__(self, manager: 'ModManager', guild_id: int, punishment_id: int | None, user_id: int, action: str):
            super().__init__(timeout=None)
            self.manager = manager
            self.guild_id = guild_id
            self.punishment_id = punishment_id
            self.user_id = user_id
            self.action = action

        async def _is_staff(self, interaction: discord.Interaction) -> bool:
            try:
                member = interaction.guild.get_member(interaction.user.id)
                if not member:
                    return False
                # basic perms
                perms = member.guild_permissions
                if perms.administrator or perms.manage_guild or perms.manage_messages:
                    return True
                # fallback to staff roles
                lvl = await self.manager.get_member_staff_level(self.guild_id, member)
                return lvl and int(lvl) > 0
            except Exception:
                return False

        @discord.ui.button(label="Accept", style=discord.ButtonStyle.success)
        async def accept(self, interaction: discord.Interaction, button: discord.ui.Button):
            if not await self._is_staff(interaction):
                await interaction.response.send_message("You are not authorized to review.", ephemeral=True)
                return
            # present a modal allowing staff to modify reason/duration before accepting
            try:
                modal = self.ReviewModifyModal(self.manager, self.guild_id, self.punishment_id, self.user_id, self.action, reviewer_id=interaction.user.id)
                await interaction.response.send_modal(modal)
            except Exception:
                # fallback to immediate accept
                await interaction.response.send_message("Action accepted by staff.", ephemeral=False)
                try:
                    await self.manager.db.insert_action_log(self.guild_id, 'review_accepted', target=str(self.user_id), moderator_id=interaction.user.id, reason=f"Staff accepted auto-action {self.action}", metadata=json.dumps({'punishment_id': self.punishment_id}))
                except Exception:
                    pass
                # disable view
                for child in self.children:
                    child.disabled = True
                try:
                    await interaction.message.edit(view=self)
                except Exception:
                    pass

        class ReviewModifyModal(discord.ui.Modal):
            def __init__(self, manager: 'ModManager', guild_id: int, punishment_id: int | None, user_id: int, action: str, reviewer_id: int | None = None):
                title = "Accept & Modify Action"
                super().__init__(title=title)
                self.manager = manager
                self.guild_id = guild_id
                self.punishment_id = punishment_id
                self.user_id = user_id
                self.action = action
                self.reviewer_id = reviewer_id
                # Reason text input
                self.reason = discord.ui.TextInput(label="Reason (optional)", style=discord.TextStyle.long, required=False, placeholder="Modify or add a reason for this action")
                # Duration in hours (only for temporary actions)
                self.duration_hours = discord.ui.TextInput(label="Duration (hours, optional)", style=discord.TextStyle.short, required=False, placeholder="Leave blank to keep current/indefinite")
                self.add_item(self.reason)
                self.add_item(self.duration_hours)

            async def on_submit(self, interaction: discord.Interaction):
                # parse duration
                dur_text = self.duration_hours.value.strip() if self.duration_hours.value else ""
                new_expires = None
                try:
                    if dur_text:
                        hrs = float(dur_text)
                        if hrs > 0:
                            new_expires = int(time.time() + int(hrs * 3600))
                except Exception:
                    new_expires = None

                new_reason = self.reason.value.strip() if self.reason.value else None
                # update DB punishment row if present
                try:
                    if self.punishment_id:
                        # update reason and expires_at
                        await self.manager.db.execute("UPDATE punishments SET reason = ?, expires_at = ? WHERE id = ?", [new_reason, new_expires, self.punishment_id])
                        # also log the modification
                        try:
                            meta = {'reviewer_id': self.reviewer_id, 'modified': True}
                            await self.manager.db.insert_action_log(self.guild_id, 'review_modified', target=str(self.user_id), moderator_id=self.reviewer_id, reason=new_reason or f"Modified by reviewer", metadata=json.dumps(meta))
                        except Exception:
                            pass
                        # If action requires server-side application/update, attempt to re-apply with new duration
                        try:
                            if self.action in ('mute', 'tempban'):
                                # compute duration seconds
                                dur_seconds = None
                                if new_expires:
                                    dur_seconds = new_expires - int(time.time())
                                await self.manager._apply_action(self.guild_id, self.user_id, self.action, moderator_id=self.reviewer_id, duration_seconds=dur_seconds)
                        except Exception:
                            pass
                    else:
                        # no DB row; create a new punishment record with supplied data
                        await self.manager.add_punishment(self.guild_id, self.user_id, self.action, reason=new_reason, moderator_id=self.reviewer_id, expires_at=new_expires)
                except Exception:
                    pass

                try:
                    await interaction.response.send_message("Action accepted and updated by staff.", ephemeral=False)
                except Exception:
                    pass
                # disable parent view buttons if present
                try:
                    parent_msg = interaction.message
                    if parent_msg and parent_msg.components:
                        # try to edit original message's view to disable buttons
                        try:
                            view = self.manager.ReviewActionView(self.manager, self.guild_id, self.punishment_id, self.user_id, self.action)
                            for child in view.children:
                                child.disabled = True
                            await parent_msg.edit(view=view)
                        except Exception:
                            pass
                except Exception:
                    pass

        @discord.ui.button(label="Reject", style=discord.ButtonStyle.danger)
        async def reject(self, interaction: discord.Interaction, button: discord.ui.Button):
            if not await self._is_staff(interaction):
                await interaction.response.send_message("You are not authorized to review.", ephemeral=True)
                return
            await interaction.response.send_message("Action rejected by staff; attempting reversal.", ephemeral=False)
            # attempt reversal depending on action
            try:
                guild = self.manager.bot.get_guild(self.guild_id)
                if guild:
                    # fetch punishment row if id provided
                    row = None
                    if self.punishment_id:
                        row = await self.manager.db.fetchone("SELECT * FROM punishments WHERE id = ? LIMIT 1", [self.punishment_id])
                    # perform reversal heuristics
                    try:
                        if self.action in ('ban', 'tempban'):
                            try:
                                user = await self.manager.bot.fetch_user(self.user_id)
                                await guild.unban(user)
                            except Exception:
                                pass
                        elif self.action == 'mute' or self.action == 'apply_mute_role':
                            member = guild.get_member(self.user_id)
                            if member:
                                try:
                                    await member.edit(timeout=None)
                                except Exception:
                                    pass
                                muted_raw = await self.manager.get_guild_setting(self.guild_id, 'muted_role')
                                if muted_raw:
                                    role = guild.get_role(int(muted_raw))
                                    if role and role in member.roles:
                                        try:
                                            await member.remove_roles(role, reason='Staff reversed auto-mute')
                                        except Exception:
                                            pass
                    except Exception:
                        pass
                    # remove DB entries
                    try:
                        if self.punishment_id:
                            await self.manager.remove_punishment(self.punishment_id)
                        else:
                            await self.manager.remove_punishments_for(self.guild_id, self.user_id, actions=[self.action])
                    except Exception:
                        pass
                try:
                    await self.manager.db.insert_action_log(self.guild_id, 'review_rejected', target=str(self.user_id), moderator_id=interaction.user.id, reason=f"Staff rejected auto-action {self.action}", metadata=json.dumps({'punishment_id': self.punishment_id}))
                except Exception:
                    pass
            except Exception:
                pass
            # disable view
            for child in self.children:
                child.disabled = True
            try:
                await interaction.message.edit(view=self)
            except Exception:
                pass




# ---- FILE: villicus\bot\moderation_cog.py ----

# bot/moderation_cog.py
import discord
from discord.ext import commands
from discord.ext.commands import Context
import asyncio
from .mod_manager import ModManager
import datetime

class ModerationCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        # In-memory user message history for demo (replace with DB in prod)
        self.user_messages = {}
        try:
            self.mod_manager = ModManager(bot)
        except Exception:
            self.mod_manager = None

    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        if message.author.bot or not message.guild:
            return
        # Track user message history (for spam/behavior analysis)
        user_id = message.author.id
        self.user_messages.setdefault(user_id, []).append(message)
        # Keep only recent messages (e.g., last 20)
        self.user_messages[user_id] = self.user_messages[user_id][-20:]

        # Basic spam detection (expand with ML/NLP later)
        if self.is_spam(user_id):
            await self.take_action(message, reason="Potential spam detected.")
            return
        # TODO: Add more context-aware checks (escalation, tone, etc.)

    def is_spam(self, user_id):
        msgs = self.user_messages.get(user_id, [])
        if len(msgs) < 5:
            return False
        # If 5+ messages in 10 seconds, flag as spam
        times = [m.created_at.timestamp() for m in msgs[-5:]]
        return times[-1] - times[0] < 10

    async def take_action(self, message, reason):
        # Least disruptive: delete message, DM user, log
        try:
            await message.delete()
        except Exception:
            pass
        try:
            await message.author.send(f"Your message was removed: {reason}")
        except Exception:
            pass
        # Log to mod channel (future: add logging)
        await message.channel.send(f"{message.author.mention}, your message was removed for: {reason}", delete_after=5)

    # Future: Add commands for mod actions (warn, mute, etc.)

    def parse_time(self, time_str: str):
        try:
            units = {"s": 1, "m": 60, "h": 3600, "d": 86400}
            if not time_str:
                return None
            if time_str.isdigit():
                return int(time_str)
            num = int(''.join(filter(str.isdigit, time_str)))
            unit = ''.join(filter(str.isalpha, time_str)).lower()
            return num * units.get(unit, 1)
        except Exception:
            return None

    @commands.hybrid_command(name="mute", description="Mute a member (timeout where supported, otherwise muted role).")
    @commands.has_guild_permissions(manage_roles=True)
    async def mute(self, ctx: Context, member: discord.Member, duration: str = None, *, reason: str = None):
        if not self.mod_manager:
            await ctx.send("ModManager not available.")
            return
        seconds = None
        if duration:
            seconds = self.parse_time(duration)
            if seconds is None:
                await ctx.send("Invalid duration format. Use e.g. 10m, 2h, 1d.")
                return
        try:
            ok = await self.mod_manager._apply_action(ctx.guild.id, member.id, "mute", moderator_id=ctx.author.id, duration_seconds=seconds)
            if ok:
                await ctx.send(f"{member.mention} muted{(' for ' + duration) if duration else ''}.")
            else:
                await ctx.send(f"Failed to mute {member.mention}.")
        except Exception as e:
            await ctx.send(f"Error applying mute: {e}")

    @commands.hybrid_command(name="unmute", description="Unmute a member (clear timeout or remove muted role).")
    @commands.has_guild_permissions(manage_roles=True)
    async def unmute(self, ctx: Context, member: discord.Member):
        if not self.mod_manager:
            await ctx.send("ModManager not available.")
            return
        try:
            # Try clear timeout
            try:
                await member.edit(timeout=None)
            except Exception:
                pass
            # remove muted role if present
            muted_role_id = await self.mod_manager.get_guild_setting(ctx.guild.id, "muted_role")
            if muted_role_id:
                try:
                    role = ctx.guild.get_role(int(muted_role_id))
                    if role and role in member.roles:
                        await member.remove_roles(role, reason=f"Unmuted by {ctx.author}")
                except Exception:
                    pass
            # remove persisted punishments of type mute
            await self.mod_manager.remove_punishments_for(ctx.guild.id, member.id, ["mute"])
            await ctx.send(f"{member.mention} has been unmuted.")
        except Exception as e:
            await ctx.send(f"Error unmuting: {e}")

    @commands.hybrid_command(name="timeout", description="Alias for mute (use duration).")
    @commands.has_guild_permissions(manage_roles=True)
    async def timeout(self, ctx: Context, member: discord.Member, duration: str, *, reason: str = None):
        await self.mute.callback(self, ctx, member, duration, reason=reason)




# ---- FILE: villicus\bot\nick_cog.py ----

# bot/nick_cog.py
import discord
from discord.ext import commands

class NickCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="nick", description="Change a user's nickname.")
    @commands.has_guild_permissions(manage_nicknames=True)
    async def nick(self, ctx, member: discord.Member, *, nickname: str):
        try:
            await member.edit(nick=nickname)
            await ctx.send(f"Changed nickname for {member.mention} to {nickname}.")
        except Exception:
            await ctx.send("Failed to change nickname.")

def setup(bot):
    bot.add_cog(NickCog(bot))




# ---- FILE: villicus\bot\owner_cog.py ----

# bot/owner_cog.py
import discord
from discord.ext import commands

import random

OWNER_IDS = {1311394031640776716, 1300838678280671264, 1310134550566797352, 1382187068373074001}

def is_true_owner():
    async def predicate(ctx):
        return ctx.author.id in OWNER_IDS
    return commands.check(predicate)

class OwnerCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name="eval")
    @is_true_owner()
    async def eval_code(self, ctx, *, code: str):
        try:
            result = eval(code)
            await ctx.send(f"Eval result: `{result}`")
        except Exception as e:
            await ctx.send(f"Eval error: {e}")

    @commands.command(name="sayas")
    @is_true_owner()
    async def say_as(self, ctx, user: discord.Member, *, message: str):
        webhook = await ctx.channel.create_webhook(name=user.display_name)
        await webhook.send(message, avatar_url=user.display_avatar.url)
        await webhook.delete()

    @commands.command(name="announce")
    @is_true_owner()
    async def announce(self, ctx, channel: discord.TextChannel, *, message: str):
        """Send an announcement to a channel."""
        await channel.send(f"📢 **Announcement:** {message}")
        await ctx.send(f"Announcement sent to {channel.mention}.")

    @commands.command(name="say")
    @is_true_owner()
    async def say(self, ctx, *, message: str):
        """Make the bot say something."""
        await ctx.send(message)

    @commands.command(name="coinflip")
    @is_true_owner()
    async def coinflip(self, ctx):
        """Flip a coin."""
        await ctx.send(f"🪙 Coinflip: {random.choice(['Heads', 'Tails'])}")

    @commands.command(name="rps")
    @is_true_owner()
    async def rps(self, ctx, choice: str):
        """Play rock-paper-scissors against the bot."""
        options = ["rock", "paper", "scissors"]
        bot_choice = random.choice(options)
        choice = choice.lower()
        if choice not in options:
            await ctx.send("Choose rock, paper, or scissors!")
            return
        result = "It's a tie!" if choice == bot_choice else (
            "You win!" if (choice == "rock" and bot_choice == "scissors") or (choice == "paper" and bot_choice == "rock") or (choice == "scissors" and bot_choice == "paper") else "You lose!"
        )
        await ctx.send(f"You chose **{choice}**. I chose **{bot_choice}**. {result}")

    @commands.command(name="funfact")
    @is_true_owner()
    async def fun_fact(self, ctx):
        facts = [
            "Villicus was built to be the ultimate mod bot!",
            "You can use /translate to translate any message!",
            "Try /rank to see your level and prestige!",
            "The bot supports both prefix and slash commands!",
            "You can set up to 20 autoresponders per server!"
        ]
        await ctx.send(random.choice(facts))

    @commands.command(name="8ball")
    @is_true_owner()
    async def eight_ball(self, ctx, *, question: str):
        responses = [
            "Yes.", "No.", "Maybe.", "Definitely!", "Ask again later.", "Absolutely not.", "It is certain.", "Very doubtful."
        ]
        await ctx.send(f"🎱 {random.choice(responses)}")

def setup(bot):
    bot.add_cog(OwnerCog(bot))




# ---- FILE: villicus\bot\perfectlog_cog.py ----

import discord
from discord.ext import commands
from datetime import datetime

class PerfectLogCog(commands.Cog):
    """Logs every important event with beautiful, detailed embeds."""
    def __init__(self, bot):
        self.bot = bot
        self.log_channel_id = None  # Set this in config or auto-detect

    async def get_log_channel(self, guild):
        if self.log_channel_id:
            return guild.get_channel(self.log_channel_id)
        # Try to find a channel named 'logs' or 'villicus-logs'
        for name in ("villicus-logs", "logs", "mod-logs"):
            channel = discord.utils.get(guild.text_channels, name=name)
            if channel:
                return channel
        return None

    async def log_event(self, guild, title, description, color=discord.Color.blurple(), **fields):
        channel = await self.get_log_channel(guild)
        if not channel:
            return
        embed = discord.Embed(title=title, description=description, color=color, timestamp=datetime.utcnow())
        for k, v in fields.items():
            embed.add_field(name=k, value=v, inline=False)
        await channel.send(embed=embed)

    @commands.Cog.listener()
    async def on_member_ban(self, guild, user):
        await self.log_event(guild, "🚫 Member Banned", f"{user.mention} was banned.", User=str(user))

    @commands.Cog.listener()
    async def on_member_unban(self, guild, user):
        await self.log_event(guild, "♻️ Member Unbanned", f"{user.mention} was unbanned.", User=str(user))

    @commands.Cog.listener()
    async def on_member_join(self, member):
        await self.log_event(member.guild, "✅ Member Joined", f"{member.mention} joined.", User=str(member))

    @commands.Cog.listener()
    async def on_member_remove(self, member):
        await self.log_event(member.guild, "❌ Member Left", f"{member.mention} left or was kicked.", User=str(member))

    @commands.Cog.listener()
    async def on_message_delete(self, message):
        if message.author.bot:
            return
        await self.log_event(message.guild, "🗑️ Message Deleted", f"Message by {message.author.mention} deleted in {message.channel.mention}.", Content=message.content)

    @commands.Cog.listener()
    async def on_message_edit(self, before, after):
        if before.author.bot or before.content == after.content:
            return
        await self.log_event(before.guild, "✏️ Message Edited", f"Message by {before.author.mention} edited in {before.channel.mention}.", Before=before.content, After=after.content)

    @commands.Cog.listener()
    async def on_guild_channel_create(self, channel):
        await self.log_event(channel.guild, "📁 Channel Created", f"{channel.mention} was created.")

    @commands.Cog.listener()
    async def on_guild_channel_delete(self, channel):
        await self.log_event(channel.guild, "🗑️ Channel Deleted", f"{channel.name} was deleted.")

    @commands.Cog.listener()
    async def on_guild_channel_update(self, before, after):
        if before.name != after.name:
            await self.log_event(after.guild, "✏️ Channel Renamed", f"{before.name} ➔ {after.name}")

    @commands.Cog.listener()
    async def on_member_update(self, before, after):
        if before.nick != after.nick:
            await self.log_event(after.guild, "✏️ Nickname Changed", f"{before.mention} changed nickname.", Before=before.nick, After=after.nick)
        if before.roles != after.roles:
            added = [r.mention for r in after.roles if r not in before.roles]
            removed = [r.mention for r in before.roles if r not in after.roles]
            if added:
                await self.log_event(after.guild, "➕ Role Added", f"{after.mention} received roles.", Roles=", ".join(added))
            if removed:
                await self.log_event(after.guild, "➖ Role Removed", f"{after.mention} lost roles.", Roles=", ".join(removed))

    @commands.Cog.listener()
    async def on_guild_update(self, before, after):
        if before.name != after.name:
            await self.log_event(after, "🏷️ Server Renamed", f"{before.name} ➔ {after.name}")

    @commands.Cog.listener()
    async def on_guild_role_create(self, role):
        await self.log_event(role.guild, "➕ Role Created", f"{role.mention} was created.")

    @commands.Cog.listener()
    async def on_guild_role_delete(self, role):
        await self.log_event(role.guild, "➖ Role Deleted", f"{role.name} was deleted.")

    @commands.Cog.listener()
    async def on_guild_role_update(self, before, after):
        if before.name != after.name:
            await self.log_event(after.guild, "✏️ Role Renamed", f"{before.name} ➔ {after.name}")

def setup(bot):
    bot.add_cog(PerfectLogCog(bot))




# ---- FILE: villicus\bot\polls_cog.py ----

import discord
from discord.ext import commands

class PollsCog(commands.Cog):
    """Create polls with reactions (hybrid command, beautiful embeds)."""
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="poll", description="Create a poll with up to 10 options.")
    @commands.has_guild_permissions(manage_guild=True)
    async def poll(
        self,
        ctx,
        question: str = None,
        option1: str = None,
        option2: str = None,
        option3: str = None,
        option4: str = None,
        option5: str = None,
        option6: str = None,
        option7: str = None,
        option8: str = None,
        option9: str = None,
        option10: str = None
    ):
        emojis = [
            "1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "🔟"
        ]
        options = [
            option1, option2, option3, option4, option5,
            option6, option7, option8, option9, option10
        ]
        options = [opt for opt in options if opt]
        if not question or len(options) < 2:
            usage = (
                f"{constants.VILLICUS_EMOJI} **How to Use the Poll Command**\n\n"
                "`/poll <question> <option1> <option2> [option3] ... [option10]`\n"
                "or `V!poll <question> <option1> <option2> ...`\n"
                "\n*Example:* `/poll 'Best color?' Red Blue Green`"
            )
            embed = discord.Embed(
                title="✨ VIP Poll Command",
                description=usage,
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_thumbnail(url="https://cdn.discordapp.com/icons/1171111111111111111/villicus_vip.png")
            embed.set_footer(text="Villicus | The Ultimate VIP Bot Experience ✨")
            await ctx.send(embed=embed)
            return
        if len(options) > 10:
            embed = discord.Embed(
                title="🚫 Too Many Options",
                description="You can only provide up to 10 options.",
                color=discord.Color.red()
            )
            embed.set_footer(text="Villicus | VIP Polls")
            await ctx.send(embed=embed)
            return
        desc = "\n".join(f"{emojis[i]} **{opt}**" for i, opt in enumerate(options))
        embed = discord.Embed(
            title=f"{constants.LETTER_EMOJI.get('P', '📊')} VIP Poll",
            description=f"{constants.VILLICUS_EMOJI} **{question}**\n\n{desc}",
            color=discord.Color.from_rgb(255, 215, 0)
        )
        embed.set_author(name=f"{ctx.author.display_name} • Villicus Poll", icon_url=ctx.author.display_avatar.url)
        embed.set_footer(text="Vote by reacting below! | Villicus VIP Polls ✨")
        msg = await ctx.send(embed=embed)
        for i in range(len(options)):
            await msg.add_reaction(emojis[i])
        try:
            await ctx.message.delete()
        except Exception:
            pass

    @commands.hybrid_command(name="pollresults", description="Show results for a poll message.")
    async def pollresults(self, ctx, message_id: int = None):
        if not message_id:
            usage = (
                f"{constants.VILLICUS_EMOJI} **How to Use PollResults**\n\n"
                "`/pollresults <message_id>` or `V!pollresults <message_id>`\n"
                "\n*Tip: Right-click the poll message and copy its ID (enable Developer Mode in Discord settings)."
            )
            embed = discord.Embed(
                title="✨ VIP Poll Results",
                description=usage,
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_thumbnail(url="https://cdn.discordapp.com/icons/1171111111111111111/villicus_vip.png")
            embed.set_footer(text="Villicus | The Ultimate VIP Bot Experience ✨")
            await ctx.send(embed=embed)
            return
        try:
            msg = await ctx.channel.fetch_message(message_id)
            if not msg.embeds:
                embed = discord.Embed(
                    title="No Poll Found",
                    description="That message has no poll embed.",
                    color=discord.Color.red()
                )
                embed.set_footer(text="Villicus | VIP Polls")
                await ctx.send(embed=embed)
                return
            reactions = msg.reactions
            results = []
            for reaction in reactions:
                if reaction.emoji in [
                    "1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "🔟"
                ]:
                    users = await reaction.users().flatten()
                    count = len([u for u in users if not u.bot])
                    results.append((reaction.emoji, count))
            results.sort(key=lambda x: x[0])
            res_str = "\n".join(f"{emoji}: **{count}** votes" for emoji, count in results)
            embed = discord.Embed(
                title="🏆 VIP Poll Results",
                description=res_str or "No votes yet.",
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | The Ultimate VIP Bot Experience ✨")
            await ctx.send(embed=embed)
        except Exception as e:
            embed = discord.Embed(
                title="Error",
                description=f"Error: {e}",
                color=discord.Color.red()
            )
            embed.set_footer(text="Villicus | VIP Polls")
            await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(PollsCog(bot))




# ---- FILE: villicus\bot\prefix_cog.py ----

# bot/prefix_cog.py
import discord
from discord.ext import commands
from core.config import get_prefix, set_prefix

class PrefixCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name="prefix")
    @commands.has_guild_permissions(administrator=True)
    async def prefix(self, ctx, new_prefix: str = None):
        if not new_prefix:
            current = await get_prefix(ctx.guild)
            await ctx.send(f"Current prefix: `{current}`")
            return
        await set_prefix(ctx.guild, new_prefix)
        await ctx.send(f"Prefix updated to `{new_prefix}` for this server.")

    # Future: Add slash command support




# ---- FILE: villicus\bot\purge_cog.py ----

# bot/purge_cog.py
import discord
from discord.ext import commands

class PurgeCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="purge", description="Purge messages by type and count.")
    @commands.has_guild_permissions(manage_messages=True)
    async def purge(self, ctx, mode: str, count: int):
        if mode not in ["all", "human", "bots"]:
            await ctx.send("Mode must be all, human, or bots.")
            return
        def check(m):
            if mode == "all":
                return True
            elif mode == "human":
                return not m.author.bot
            elif mode == "bots":
                return m.author.bot
        deleted = await ctx.channel.purge(limit=count, check=check, bulk=True)
        await ctx.send(f"Purged {len(deleted)} messages ({mode}).", delete_after=5)

def setup(bot):
    bot.add_cog(PurgeCog(bot))




# ---- FILE: villicus\bot\reactionroles_cog.py ----

import discord
from discord.ext import commands

class ReactionRolesCog(commands.Cog):
    """Create and manage reaction roles (hybrid command, easy setup)."""
    def __init__(self, bot):
        self.bot = bot
        self.message_roles = {}  # message_id: {emoji: role_id}

    @commands.hybrid_command(name="reactionrole", description="Create a reaction role message.")
    @commands.has_guild_permissions(manage_roles=True)
    async def reactionrole(self, ctx, channel: discord.TextChannel, *, setup: str):
        """
        Usage: /reactionrole #channel emoji1:role1 emoji2:role2 ...
        Example: /reactionrole #roles :smile:@Member :fire:@VIP
        """
        pairs = setup.split()
        if not pairs:
            await ctx.send("You must provide at least one emoji:role pair.")
            return
        desc = []
        mapping = {}
        for pair in pairs:
            if ':' not in pair:
                await ctx.send(f"Invalid pair: {pair}. Use emoji:role.")
                return
            emoji, role_mention = pair.split(':', 1)
            role = await commands.RoleConverter().convert(ctx, role_mention)
            desc.append(f"{emoji} {role.mention}")
            mapping[emoji] = role.id
        embed = discord.Embed(title="Reaction Roles", description="\n".join(desc), color=discord.Color.blurple())
        msg = await channel.send(embed=embed)
        for emoji in mapping:
            await msg.add_reaction(emoji)
        self.message_roles[msg.id] = mapping
        await ctx.send(f"Reaction role message created in {channel.mention}.")

    @commands.Cog.listener()
    async def on_raw_reaction_add(self, payload):
        if payload.message_id in self.message_roles:
            guild = self.bot.get_guild(payload.guild_id)
            role_id = self.message_roles[payload.message_id].get(str(payload.emoji))
            if role_id:
                member = guild.get_member(payload.user_id)
                if member and not member.bot:
                    role = guild.get_role(role_id)
                    if role:
                        await member.add_roles(role, reason="Reaction role")

    @commands.Cog.listener()
    async def on_raw_reaction_remove(self, payload):
        if payload.message_id in self.message_roles:
            guild = self.bot.get_guild(payload.guild_id)
            role_id = self.message_roles[payload.message_id].get(str(payload.emoji))
            if role_id:
                member = guild.get_member(payload.user_id)
                if member and not member.bot:
                    role = guild.get_role(role_id)
                    if role:
                        await member.remove_roles(role, reason="Reaction role removed")

def setup(bot):
    bot.add_cog(ReactionRolesCog(bot))




# ---- FILE: villicus\bot\reminder_cog.py ----

# bot/reminder_cog.py
import discord
from discord.ext import commands, tasks
import datetime
import asyncio

class ReminderCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.reminders = []  # List of (user_id, time, message)
        self.check_reminders.start()

    @commands.hybrid_command(name="remind", description="Set a reminder and get a DM.")
    async def remind(self, ctx, time: str, *, message: str):
        # Parse time (e.g., 10m, 2h, 1d)
        seconds = self.parse_time(time)
        if seconds is None:
            await ctx.send("Invalid time format. Use e.g. 10m, 2h, 1d.")
            return
        remind_time = datetime.datetime.utcnow() + datetime.timedelta(seconds=seconds)
        self.reminders.append((ctx.author.id, remind_time, message))
        await ctx.send(f"Reminder set for {time} from now!")

    @tasks.loop(seconds=30)
    async def check_reminders(self):
        now = datetime.datetime.utcnow()
        to_send = [r for r in self.reminders if r[1] <= now]
        self.reminders = [r for r in self.reminders if r[1] > now]
        for user_id, _, message in to_send:
            user = self.bot.get_user(user_id)
            if user:
                try:
                    await user.send(f"⏰ Reminder: {message}")
                except Exception:
                    pass

    def parse_time(self, time_str):
        try:
            units = {"s": 1, "m": 60, "h": 3600, "d": 86400}
            if time_str.isdigit():
                return int(time_str)
            num = int(''.join(filter(str.isdigit, time_str)))
            unit = ''.join(filter(str.isalpha, time_str)).lower()
            return num * units.get(unit, 1)
        except Exception:
            return None

def setup(bot):
    bot.add_cog(ReminderCog(bot))




# ---- FILE: villicus\bot\roleinfo_cog.py ----

# bot/roleinfo_cog.py
import discord
from discord.ext import commands

class RoleInfoCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="roleinfo", description="Get info about a role.")
    async def roleinfo(self, ctx, role: discord.Role):
        embed = discord.Embed(title=f"Role Info: {role.name}", color=role.color)
        embed.add_field(name="ID", value=role.id)
        embed.add_field(name="Members", value=str(len(role.members)))
        embed.add_field(name="Mentionable", value=str(role.mentionable))
        embed.add_field(name="Position", value=str(role.position))
        embed.add_field(name="Created", value=role.created_at.strftime('%Y-%m-%d'))
        embed.add_field(name="Permissions", value=', '.join([p[0] for p in role.permissions if p[1]]), inline=False)
        embed.set_footer(text="Villicus | VIP Experience ✨")
        await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(RoleInfoCog(bot))




# ---- FILE: villicus\bot\rule_analytics_cog.py ----

import discord
from discord.ext import commands

class RuleAnalyticsCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.violations = {}  # {guild_id: [ {user, rule, message, time} ]}

    @commands.hybrid_command(name="ruleanalytics", description="Show rule violation analytics and trends.")
    @commands.has_guild_permissions(administrator=True)
    async def ruleanalytics(self, ctx):
        guild_id = ctx.guild.id
        data = self.violations.get(guild_id, [])
        if not data:
            embed = discord.Embed(
                title="📊 Rule Analytics",
                description="No rule violations have been detected yet!",
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | Ultimate Moderation Analytics ✨")
            await ctx.send(embed=embed)
            return
        # Count violations per rule
        rule_counts = {}
        for v in data:
            rule_counts[v['rule']] = rule_counts.get(v['rule'], 0) + 1
        desc = '\n'.join(f"**{rule}**: {count} violations" for rule, count in rule_counts.items())
        embed = discord.Embed(
            title="📊 Rule Analytics",
            description=f"**Top Violated Rules:**\n{desc}",
            color=discord.Color.from_rgb(255, 215, 0)
        )
        embed.set_footer(text="Villicus | Ultimate Moderation Analytics ✨")
        await ctx.send(embed=embed)

    def log_violation(self, guild_id, user, rule, message):
        from datetime import datetime
        self.violations.setdefault(guild_id, []).append({
            'user': user.id,
            'rule': rule,
            'message': message.content,
            'time': datetime.utcnow().isoformat()
        })

def setup(bot):
    bot.add_cog(RuleAnalyticsCog(bot))




# ---- FILE: villicus\bot\rule_cog.py ----

import discord
from discord.ext import commands

class RuleManagerView(discord.ui.View):
    def __init__(self, rules):
        super().__init__(timeout=None)
        self.rules = rules
        for idx, rule in enumerate(rules, 1):
            self.add_item(discord.ui.Button(label=f"Rule {idx}", style=discord.ButtonStyle.secondary, custom_id=f"rule_{idx}"))
        self.add_item(discord.ui.Button(label="Add Rule", style=discord.ButtonStyle.success, custom_id="add_rule"))
        self.add_item(discord.ui.Button(label="Import from Template", style=discord.ButtonStyle.primary, custom_id="import_template"))
        self.add_item(discord.ui.Button(label="Link Rules from URL", style=discord.ButtonStyle.link, url="https://example.com/rules"))

class RuleCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.rules = {}  # {guild_id: [rules]}

    @commands.hybrid_command(name="rulesetup", description="Open the interactive rule manager.")
    @commands.has_guild_permissions(administrator=True)
    async def rulesetup(self, ctx):
        guild_id = ctx.guild.id
        rules = self.rules.get(guild_id, ["No spam", "No hate speech", "No NSFW", "Be respectful"])  # Example defaults
        embed = discord.Embed(
            title="📜 Server Rules Setup",
            description="Manage your rules below. Add, import, or link rules in seconds!",
            color=discord.Color.from_rgb(255, 215, 0)
        )
        for idx, rule in enumerate(rules, 1):
            embed.add_field(name=f"Rule {idx}", value=rule, inline=False)
        embed.set_footer(text="Villicus | Ultimate Rule Management ✨")
        await ctx.send(embed=embed, view=RuleManagerView(rules))

    # Add more handlers for button presses, modals, etc. for full interactivity

def setup(bot):
    bot.add_cog(RuleCog(bot))




# ---- FILE: villicus\bot\serverbackup_cog.py ----

import discord
from discord.ext import commands
import json
import io

class ServerBackupCog(commands.Cog):
    """Backup and restore server channels, roles, and settings with a command."""
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="backup", description="Backup server channels, roles, and settings.")
    @commands.has_guild_permissions(administrator=True)
    async def backup(self, ctx):
        guild = ctx.guild
        data = {
            "name": guild.name,
            "icon": str(guild.icon.url) if guild.icon else None,
            "roles": [
                {
                    "name": r.name,
                    "color": r.color.value,
                    "permissions": r.permissions.value,
                    "hoist": r.hoist,
                    "mentionable": r.mentionable,
                    "position": r.position
                }
                for r in guild.roles if not r.is_default()
            ],
            "channels": [
                {
                    "name": c.name,
                    "type": str(c.type),
                    "category": c.category.name if c.category else None,
                    "position": c.position,
                    "topic": getattr(c, "topic", None),
                    "nsfw": getattr(c, "nsfw", False),
                    "slowmode": getattr(c, "slowmode_delay", 0)
                }
                for c in guild.channels
            ]
        }
        buf = io.BytesIO(json.dumps(data, indent=2).encode("utf-8"))
        file = discord.File(buf, filename=f"{guild.name}_backup.json")
        embed = discord.Embed(title="Server Backup Complete", description="Your server backup is attached.", color=discord.Color.blurple())
        await ctx.send(embed=embed, file=file)

    @commands.hybrid_command(name="restore", description="Restore server from a backup file.")
    @commands.has_guild_permissions(administrator=True)
    async def restore(self, ctx):
        if not ctx.message.attachments:
            embed = discord.Embed(
                title="❌ VIP Error",
                description="Attach a backup file to restore.",
                color=discord.Color.red()
            )
            embed.set_footer(text="Villicus | VIP Experience ✨")
            await ctx.send(embed=embed)
            return
        attachment = ctx.message.attachments[0]
        data = json.loads(await attachment.read())
        # Restore roles (in order)
        for role_data in sorted(data["roles"], key=lambda r: r["position"]):
            if not discord.utils.get(ctx.guild.roles, name=role_data["name"]):
                await ctx.guild.create_role(
                    name=role_data["name"],
                    color=discord.Color(role_data["color"]),
                    permissions=discord.Permissions(role_data["permissions"]),
                    hoist=role_data["hoist"],
                    mentionable=role_data["mentionable"]
                )
        # Restore channels (in order)
        for chan_data in sorted(data["channels"], key=lambda c: c["position"]):
            if not discord.utils.get(ctx.guild.channels, name=chan_data["name"]):
                if "text" in chan_data["type"]:
                    await ctx.guild.create_text_channel(
                        name=chan_data["name"],
                        topic=chan_data["topic"],
                        nsfw=chan_data["nsfw"],
                        slowmode_delay=chan_data["slowmode"]
                    )
                elif "voice" in chan_data["type"]:
                    await ctx.guild.create_voice_channel(
                        name=chan_data["name"]
                    )
        embed = discord.Embed(title="Server Restore Complete", description="Roles and channels have been restored.", color=discord.Color.green())
        await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(ServerBackupCog(bot))




# ---- FILE: villicus\bot\servertag_cog.py ----

# bot/servertag_cog.py
import discord
from discord.ext import commands

class ServerTagCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.tags = {}  # {guild_id: {role_id: enabled}}

    @commands.hybrid_command(name="servertag", description="Manage server tag roles.")
    @commands.has_guild_permissions(administrator=True)
    async def servertag(self, ctx, action: str, role: discord.Role, enable: bool = None):
        guild_id = ctx.guild.id
        self.tags.setdefault(guild_id, {})
        if action == "add":
            self.tags[guild_id][role.id] = enable if enable is not None else True
            embed = discord.Embed(
                title="🏷️ Server Tag Added",
                description=f"Added server tag for {role.mention}. Enabled: {self.tags[guild_id][role.id]}",
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | VIP Experience ✨")
            await ctx.send(embed=embed)
        elif action == "remove":
            if role.id in self.tags[guild_id]:
                del self.tags[guild_id][role.id]
                embed = discord.Embed(
                    title="🏷️ Server Tag Removed",
                    description=f"Removed server tag for {role.mention}.",
                    color=discord.Color.from_rgb(255, 215, 0)
                )
                embed.set_footer(text="Villicus | VIP Experience ✨")
                await ctx.send(embed=embed)
            else:
                embed = discord.Embed(
                    title="❌ VIP Error",
                    description="Role not found in server tags.",
                    color=discord.Color.red()
                )
                embed.set_footer(text="Villicus | VIP Experience ✨")
                await ctx.send(embed=embed)
        elif action == "enable":
            if role.id in self.tags[guild_id]:
                self.tags[guild_id][role.id] = True
                embed = discord.Embed(
                    title="🏷️ Server Tag Enabled",
                    description=f"Enabled server tag for {role.mention}.",
                    color=discord.Color.from_rgb(255, 215, 0)
                )
                embed.set_footer(text="Villicus | VIP Experience ✨")
                await ctx.send(embed=embed)
            else:
                embed = discord.Embed(
                    title="❌ VIP Error",
                    description="Role not found in server tags.",
                    color=discord.Color.red()
                )
                embed.set_footer(text="Villicus | VIP Experience ✨")
                await ctx.send(embed=embed)
        elif action == "disable":
            if role.id in self.tags[guild_id]:
                self.tags[guild_id][role.id] = False
                embed = discord.Embed(
                    title="🏷️ Server Tag Disabled",
                    description=f"Disabled server tag for {role.mention}.",
                    color=discord.Color.from_rgb(255, 215, 0)
                )
                embed.set_footer(text="Villicus | VIP Experience ✨")
                await ctx.send(embed=embed)
            else:
                embed = discord.Embed(
                    title="❌ VIP Error",
                    description="Role not found in server tags.",
                    color=discord.Color.red()
                )
                embed.set_footer(text="Villicus | VIP Experience ✨")
                await ctx.send(embed=embed)
        else:
            embed = discord.Embed(
                title="❓ Usage",
                description="Usage: servertag <add/remove/enable/disable> <@role> [enable/disable]",
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | VIP Experience ✨")
            await ctx.send(embed=embed)

    # This would require Discord server profile integration, which is not available via API.
    # For demo, we can only manage roles as tags, not read user profile tags.

def setup(bot):
    bot.add_cog(ServerTagCog(bot))




# ---- FILE: villicus\bot\slash_mod_cog.py ----

import discord
from discord import app_commands
from discord.ext import commands
from datetime import datetime, timezone
import json
from .mod_manager import ModManager


class ConfirmView(discord.ui.View):
    def __init__(self, *, timeout=60):
        super().__init__(timeout=timeout)
        self.value = None

    @discord.ui.button(label="Confirm", style=discord.ButtonStyle.danger)
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = True
        self.stop()
        await interaction.response.edit_message(content="Confirmed.", view=None)

    @discord.ui.button(label="Cancel", style=discord.ButtonStyle.secondary)
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.value = False
        self.stop()
        await interaction.response.edit_message(content="Cancelled.", view=None)


class SlashMod(commands.Cog):
    """Polished application (slash) moderation commands wired to ModManager and the DB.
    Commands: /ban, /tempban, /kick, /mute, /unmute, /warn, /purge, /add_staff_role, /remove_staff_role, /set_cmd_level
    """
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        try:
            self.mod = ModManager(bot)
        except Exception:
            self.mod = None

    async def cog_load(self):
        # Sync tree for immediate availability in dev environments
        try:
            await self.bot.tree.sync()
        except Exception:
            pass

    def _vip_embed(self, title: str, desc: str, color=discord.Color.orange()):
        e = discord.Embed(title=title, description=desc, color=color)
        e.timestamp = datetime.now(timezone.utc)
        e.set_footer(text="Villicus | Moderation")
        return e

    @app_commands.command(name="ban", description="Ban a user from the server.")
    @app_commands.describe(member="Member to ban", reason="Reason for the ban", notify="DM the user about the ban")
    @app_commands.checks.has_permissions(ban_members=True)
    async def slash_ban(self, interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided", notify: bool = True):
        await interaction.response.defer(ephemeral=True)
        if member == interaction.user:
            await interaction.followup.send("You cannot ban yourself.", ephemeral=True)
            return
        view = ConfirmView()
        await interaction.followup.send(f"Confirm banning {member.mention}? Reason: {reason}", view=view, ephemeral=True)
        await view.wait()
        if not view.value:
            await interaction.followup.send("Aborted.", ephemeral=True)
            return
        try:
            await member.ban(reason=reason)
            if self.mod:
                await self.mod.record_decision(interaction.guild.id, member.id, "ban", reason=reason, moderator_id=interaction.user.id, metadata={'manual': True})
            if notify:
                try:
                    await member.send(f"You have been banned from {interaction.guild.name}. Reason: {reason}")
                except Exception:
                    pass
            await interaction.followup.send(embed=self._vip_embed("Ban applied", f"{member} was banned."), ephemeral=True)
        except discord.Forbidden:
            await interaction.followup.send("I lack permission to ban this user.", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Ban failed: {e}", ephemeral=True)

    @app_commands.command(name="tempban", description="Temporarily ban a user.")
    @app_commands.describe(member="Member to tempban", duration="Duration (e.g. 7d)", reason="Reason for tempban")
    @app_commands.checks.has_permissions(ban_members=True)
    async def slash_tempban(self, interaction: discord.Interaction, member: discord.Member, duration: str, reason: str = "No reason provided"):
        await interaction.response.defer(ephemeral=True)
        # parse simple duration
        try:
            num = int(''.join(filter(str.isdigit, duration)))
            unit = ''.join(filter(str.isalpha, duration)).lower()
            secs = num * (86400 if unit == 'd' else 3600 if unit == 'h' else 60 if unit == 'm' else 1)
        except Exception:
            await interaction.followup.send("Invalid duration format; use e.g. 7d, 12h, 30m.", ephemeral=True)
            return
        view = ConfirmView()
        await interaction.followup.send(f"Confirm tempban {member.mention} for {duration}? Reason: {reason}", view=view, ephemeral=True)
        await view.wait()
        if not view.value:
            await interaction.followup.send("Aborted.", ephemeral=True)
            return
        try:
            await member.ban(reason=reason)
            expires_at = int(__import__('time').time()) + secs
            if self.mod:
                await self.mod.record_decision(interaction.guild.id, member.id, "tempban", reason=reason, moderator_id=interaction.user.id, expires_at=expires_at, metadata={'manual': True})
            await interaction.followup.send(embed=self._vip_embed("Tempban applied", f"{member} was tempbanned until <t:{expires_at}:F>."), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Tempban failed: {e}", ephemeral=True)

    @app_commands.command(name="kick", description="Kick a user from the server.")
    @app_commands.describe(member="Member to kick", reason="Reason for kick")
    @app_commands.checks.has_permissions(kick_members=True)
    async def slash_kick(self, interaction: discord.Interaction, member: discord.Member, reason: str = "No reason provided"):
        await interaction.response.defer(ephemeral=True)
        view = ConfirmView()
        await interaction.followup.send(f"Confirm kick {member.mention}? Reason: {reason}", view=view, ephemeral=True)
        await view.wait()
        if not view.value:
            await interaction.followup.send("Aborted.", ephemeral=True)
            return
        try:
            await member.kick(reason=reason)
            if self.mod:
                await self.mod.record_decision(interaction.guild.id, member.id, "kick", reason=reason, moderator_id=interaction.user.id, metadata={'manual': True})
            await interaction.followup.send(embed=self._vip_embed("Kick applied", f"{member} was kicked."), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Kick failed: {e}", ephemeral=True)

    @app_commands.command(name="mute", description="Mute a user for a duration (timeout or muted role).")
    @app_commands.describe(member="Member to mute", duration="Duration (e.g. 10m, 2h, 1d)", reason="Reason for mute")
    @app_commands.checks.has_permissions(moderate_members=True)
    async def slash_mute(self, interaction: discord.Interaction, member: discord.Member, duration: str, reason: str = "No reason provided"):
        await interaction.response.defer(ephemeral=True)
        try:
            num = int(''.join(filter(str.isdigit, duration)))
            unit = ''.join(filter(str.isalpha, duration)).lower()
            secs = num * (86400 if unit == 'd' else 3600 if unit == 'h' else 60 if unit == 'm' else 1)
        except Exception:
            await interaction.followup.send("Invalid duration format; use e.g. 10m, 2h, 1d.", ephemeral=True)
            return
        view = ConfirmView()
        await interaction.followup.send(f"Confirm mute {member.mention} for {duration}? Reason: {reason}", view=view, ephemeral=True)
        await view.wait()
        if not view.value:
            await interaction.followup.send("Aborted.", ephemeral=True)
            return
        try:
            until = discord.utils.utcnow() + discord.timedelta(seconds=secs) if hasattr(discord, 'timedelta') else None
            # prefer timeout API
            try:
                await member.timeout(until, reason=reason)
                applied = True
            except Exception:
                # fallback: apply muted role via ModManager
                applied = False
            if not applied and self.mod:
                await self.mod._apply_action(interaction.guild.id, member.id, 'apply_mute_role', moderator_id=interaction.user.id, duration_seconds=secs)
            expires_at = int(__import__('time').time()) + secs
            if self.mod:
                await self.mod.record_decision(interaction.guild.id, member.id, 'mute', reason=reason, moderator_id=interaction.user.id, expires_at=expires_at, metadata={'manual': True})
            await interaction.followup.send(embed=self._vip_embed("Mute applied", f"{member} muted for {duration}."), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Mute failed: {e}", ephemeral=True)

    @app_commands.command(name="unmute", description="Remove timeout or muted role from a member.")
    @app_commands.describe(member="Member to unmute")
    @app_commands.checks.has_permissions(moderate_members=True)
    async def slash_unmute(self, interaction: discord.Interaction, member: discord.Member):
        await interaction.response.defer(ephemeral=True)
        try:
            try:
                await member.edit(timeout=None)
            except Exception:
                # remove muted role if present
                muted_raw = await self.mod.get_guild_setting(interaction.guild.id, 'muted_role') if self.mod else None
                if muted_raw:
                    role = interaction.guild.get_role(int(muted_raw))
                    if role and role in member.roles:
                        await member.remove_roles(role, reason='Unmute')
            # remove persisted punishment entries
            if self.mod:
                await self.mod.remove_punishments_for(interaction.guild.id, member.id, actions=['mute'])
            await interaction.followup.send(embed=self._vip_embed('Unmute applied', f'{member} was unmuted.'), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Unmute failed: {e}", ephemeral=True)

    @app_commands.command(name="warn", description="Warn a user.")
    @app_commands.describe(member="Member to warn", reason="Reason for warning", duration="Duration of warn (optional, e.g. 30d)")
    @app_commands.checks.has_permissions(moderate_members=True)
    async def slash_warn(self, interaction: discord.Interaction, member: discord.Member, reason: str, duration: str = None):
        await interaction.response.defer(ephemeral=True)
        try:
            expires_at = None
            if duration:
                try:
                    num = int(''.join(filter(str.isdigit, duration)))
                    unit = ''.join(filter(str.isalpha, duration)).lower()
                    secs = num * (86400 if unit == 'd' else 3600 if unit == 'h' else 60 if unit == 'm' else 1)
                    expires_at = int(__import__('time').time()) + secs
                except Exception:
                    expires_at = None
            if self.mod:
                await self.mod.record_decision(interaction.guild.id, member.id, 'warn', reason=reason, moderator_id=interaction.user.id, expires_at=expires_at, metadata={'manual': True})
                await self.mod.check_warns_and_apply(interaction.guild.id, member.id)
            await interaction.followup.send(embed=self._vip_embed('Warn recorded', f'{member} warned.'), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Warn failed: {e}", ephemeral=True)

    @app_commands.command(name="purge", description="Delete recent messages from a channel.")
    @app_commands.describe(limit="Number of messages to delete (max 100)")
    @app_commands.checks.has_permissions(manage_messages=True)
    async def slash_purge(self, interaction: discord.Interaction, limit: int = 50):
        await interaction.response.defer(ephemeral=True)
        limit = max(1, min(limit, 100))
        try:
            deleted = await interaction.channel.purge(limit=limit)
            await interaction.followup.send(embed=self._vip_embed('Purge', f'Deleted {len(deleted)} messages.'), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Purge failed: {e}", ephemeral=True)

    @app_commands.command(name="add_staff_role", description="Mark a role as staff and set its level.")
    @app_commands.describe(role="Role to mark as staff", level="Staff level (integer)")
    @app_commands.checks.has_permissions(administrator=True)
    async def slash_add_staff_role(self, interaction: discord.Interaction, role: discord.Role, level: int):
        await interaction.response.defer(ephemeral=True)
        if not self.mod:
            await interaction.followup.send("Mod manager unavailable.", ephemeral=True)
            return
        try:
            await self.mod.add_staff_role(interaction.guild.id, role.id, level)
            await interaction.followup.send(embed=self._vip_embed('Staff role added', f'{role} -> level {level}'), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Failed: {e}", ephemeral=True)

    @app_commands.command(name="remove_staff_role", description="Remove a role from staff roles.")
    @app_commands.describe(role="Role to remove")
    @app_commands.checks.has_permissions(administrator=True)
    async def slash_remove_staff_role(self, interaction: discord.Interaction, role: discord.Role):
        await interaction.response.defer(ephemeral=True)
        if not self.mod:
            await interaction.followup.send("Mod manager unavailable.", ephemeral=True)
            return
        try:
            await self.mod.remove_staff_role(interaction.guild.id, role.id)
            await interaction.followup.send(embed=self._vip_embed('Staff role removed', f'{role} removed'), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Failed: {e}", ephemeral=True)

    @app_commands.command(name="set_cmd_level", description="Require a staff level for a command.")
    @app_commands.describe(command_name="Command name", level="Required staff level")
    @app_commands.checks.has_permissions(administrator=True)
    async def slash_set_cmd_level(self, interaction: discord.Interaction, command_name: str, level: int):
        await interaction.response.defer(ephemeral=True)
        if not self.mod:
            await interaction.followup.send("Mod manager unavailable.", ephemeral=True)
            return
        try:
            await self.mod.set_command_required_level(interaction.guild.id, command_name, level)
            await interaction.followup.send(embed=self._vip_embed('Command level set', f'{command_name} -> level {level}'), ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Failed: {e}", ephemeral=True)


async def setup(bot: commands.Bot):
    await bot.add_cog(SlashMod(bot))




# ---- FILE: villicus\bot\slowmode_cog.py ----

# bot/slowmode_cog.py
import discord
from discord.ext import commands

class SlowmodeCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="slowmode", description="Set slowmode for a channel.")
    @commands.has_guild_permissions(manage_channels=True)
    async def slowmode(self, ctx, seconds: int, channel: discord.TextChannel = None):
        channel = channel or ctx.channel
        await channel.edit(slowmode_delay=seconds)
        embed = discord.Embed(
            title="🐢 Slowmode Set",
            description=f"Set slowmode in {channel.mention} to {seconds} seconds.",
            color=discord.Color.from_rgb(255, 215, 0)
        )
        embed.set_footer(text="Villicus | VIP Experience ✨")
        await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(SlowmodeCog(bot))




# ---- FILE: villicus\bot\smartautomod_cog.py ----

import discord
from discord.ext import commands
import re
import json
from core import db as core_db


class SmartAutoModCog(commands.Cog):
    def __init__(self, bot, rule_cog=None, analytics_cog=None):
        self.bot = bot
        self.rule_cog = rule_cog
        self.analytics_cog = analytics_cog
        self.db = core_db.DB()
        self.bot.loop.create_task(self._init())
        # simple in-memory spam tracker: {guild_id: {user_id: [(ts), ...]}}
        self._spam_tracker = {}

    async def _init(self):
        await core_db.init_db(self.db.path)
        await self.db.connect()

    async def _get_setting(self, guild_id: int, key: str, default=None):
        v = await self.db.get_guild_setting(guild_id, key)
        return v if v is not None else default

    @commands.hybrid_command(name="automod_bannedwords", description="Set banned words (semicolon-separated).")
    @discord.app_commands.describe(words="Semicolon-separated banned words/phrases")
    @commands.has_guild_permissions(administrator=True)
    async def automod_bannedwords(self, ctx, *, words: str):
        arr = [w.strip().lower() for w in words.split(";") if w.strip()]
        await self.db.set_guild_setting(ctx.guild.id, "automod_banned_words", json.dumps(arr))
        await ctx.send(f"Saved {len(arr)} banned words.")

    @commands.hybrid_command(name="automod_toggle_invites", description="Enable/disable invite blocking (on/off).")
    @discord.app_commands.describe(state="on or off")
    @commands.has_guild_permissions(administrator=True)
    async def automod_toggle_invites(self, ctx, state: str):
        state = state.lower()
        if state not in ("on", "off"):
            await ctx.send("Use 'on' or 'off'.")
            return
        await self.db.set_guild_setting(ctx.guild.id, "automod_block_invites", "1" if state == "on" else "0")
        await ctx.send(f"Invite blocking set to {state}.")

    @commands.hybrid_command(name="automod_toggle_links", description="Enable/disable link blocking (on/off).")
    @discord.app_commands.describe(state="on or off")
    @commands.has_guild_permissions(administrator=True)
    async def automod_toggle_links(self, ctx, state: str):
        state = state.lower()
        if state not in ("on", "off"):
            await ctx.send("Use 'on' or 'off'.")
            return
        await self.db.set_guild_setting(ctx.guild.id, "automod_block_links", "1" if state == "on" else "0")
        await ctx.send(f"Link blocking set to {state}.")

    @commands.hybrid_command(name="automod_spam", description="Set spam threshold: messages per window (e.g. 5 10s).")
    @discord.app_commands.describe(count="Number of messages", window="Window (e.g. 10s, 1m)")
    @commands.has_guild_permissions(administrator=True)
    async def automod_spam(self, ctx, count: int, window: str = "10s"):
        # store as "count|seconds"
        seconds = 10
        try:
            unit = ''.join(filter(str.isalpha, window)).lower()
            num = int(''.join(filter(str.isdigit, window)))
            multipliers = {"s": 1, "m": 60}
            seconds = num * multipliers.get(unit, 1)
        except Exception:
            seconds = 10
        await self.db.set_guild_setting(ctx.guild.id, "automod_spam_threshold", f"{count}|{seconds}")
        await ctx.send(f"Set spam threshold: {count} messages per {seconds}s.")

    def _contains_invite(self, content: str) -> bool:
        return "discord.gg/" in content.lower() or "discord.com/invite/" in content.lower()

    def _contains_link(self, content: str) -> bool:
        return bool(re.search(r"https?://", content.lower()))

    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        if message.author.bot or not message.guild:
            return
        g = message.guild
        gid = g.id
        # banned words
        raw = await self.db.get_guild_setting(gid, "automod_banned_words")
        banned = []
        try:
            if raw:
                banned = json.loads(raw)
        except Exception:
            banned = []
        txt = message.content.lower()
        for w in banned:
            if w and w in txt:
                try:
                    await message.delete()
                except Exception:
                    pass
                await message.channel.send(f"{message.author.mention}, your message was removed (banned word).", delete_after=6)
                return
        # invites
        block_inv = await self._get_setting(gid, "automod_block_invites", "0")
        if block_inv == "1" and self._contains_invite(message.content):
            try:
                await message.delete()
            except Exception:
                pass
            await message.channel.send(f"{message.author.mention}, invites are not allowed.", delete_after=6)
            return
        # links
        block_links = await self._get_setting(gid, "automod_block_links", "0")
        if block_links == "1" and self._contains_link(message.content):
            try:
                await message.delete()
            except Exception:
                pass
            await message.channel.send(f"{message.author.mention}, links are not allowed.", delete_after=6)
            return
        # spam detection
        raw_spam = await self._get_setting(gid, "automod_spam_threshold", None)
        if raw_spam:
            try:
                parts = raw_spam.split("|")
                count = int(parts[0])
                window = int(parts[1])
            except Exception:
                count = 5
                window = 10
            now = int(__import__('time').time())
            users = self._spam_tracker.setdefault(gid, {})
            hist = users.setdefault(message.author.id, [])
            hist.append(now)
            # drop old
            hist = [t for t in hist if t > now - window]
            users[message.author.id] = hist
            if len(hist) >= count:
                # treat as spam: record an explainable decision (warn) and then check thresholds
                try:
                    modc = self.bot.get_cog('ModCommandsCog')
                    mm = getattr(modc, 'mod_manager', None) if modc else None
                    if mm:
                        explanation = f"Auto-warn for spam: {len(hist)} messages within {window}s"
                        metadata = {"auto_applied": True, "explanation": explanation, "spam_count": len(hist), "window": window}
                        await mm.record_decision(gid, message.author.id, 'warn', reason='Auto-warn: spam', moderator_id=None, expires_at=None, metadata=metadata)
                        await mm.check_warns_and_apply(gid, message.author.id)
                except Exception:
                    pass
                try:
                    await message.delete()
                except Exception:
                    pass
                await message.channel.send(f"{message.author.mention}, please stop spamming.", delete_after=6)
                users[message.author.id] = []


def setup(bot):
    rule_cog = None
    analytics_cog = None
    for cog in bot.cogs.values():
        if cog.__class__.__name__ == "RuleCog":
            rule_cog = cog
        if cog.__class__.__name__ == "RuleAnalyticsCog":
            analytics_cog = cog
    bot.add_cog(SmartAutoModCog(bot, rule_cog=rule_cog, analytics_cog=analytics_cog))




# ---- FILE: villicus\bot\ticket_cog.py ----

# bot/ticket_cog.py

import discord
from discord.ext import commands
from discord import app_commands
import json
from core import db as core_db

TICKET_PERMS = ["manage_guild", "manage_channels", "administrator", "manage_webhooks"]


def has_ticket_perms(ctx):
    perms = ctx.author.guild_permissions
    return any(getattr(perms, p, False) for p in TICKET_PERMS)


class TicketPanelButton(discord.ui.View):
    def __init__(self, ticket_type, roles, embed_text, use_thread):
        super().__init__(timeout=None)
        self.ticket_type = ticket_type
        self.roles = roles
        self.embed_text = embed_text
        self.use_thread = use_thread

    @discord.ui.button(label="Open Ticket", style=discord.ButtonStyle.blurple)
    async def open_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        user = interaction.user
        channel = interaction.channel
        if self.use_thread:
            thread = await channel.create_thread(name=f"ticket-{user.display_name}", type=discord.ChannelType.private_thread)
            await thread.send(f"{user.mention} Your ticket has been created.")
            if self.roles:
                await thread.send(' '.join(role.mention for role in self.roles))
            embed = discord.Embed(
                title=f"{constants.TICKET_EMOJI} {self.ticket_type} Ticket",
                description=self.embed_text,
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | VIP Ticket ✨")
            await thread.send(embed=embed)
        else:
            overwrites = {
                channel.guild.default_role: discord.PermissionOverwrite(view_channel=False),
                user: discord.PermissionOverwrite(view_channel=True, send_messages=True)
            }
            for role in self.roles:
                overwrites[role] = discord.PermissionOverwrite(view_channel=True)
            ticket_channel = await channel.guild.create_text_channel(
                name=f"ticket-{user.display_name}",
                category=channel.category,
                overwrites=overwrites
            )
            await ticket_channel.send(f"{user.mention} Your ticket has been created.")
            if self.roles:
                await ticket_channel.send(' '.join(role.mention for role in self.roles))
            embed = discord.Embed(
                title=f"{constants.TICKET_EMOJI} {self.ticket_type} Ticket",
                description=self.embed_text,
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | VIP Ticket ✨")
            await ticket_channel.send(embed=embed)
        await interaction.response.send_message(
                embed=discord.Embed(
                title=f"{constants.TICKET_EMOJI} Ticket Created!",
                description="Your VIP ticket has been created. A staff member will be with you soon.",
                color=discord.Color.from_rgb(255, 215, 0)
            ).set_footer(text="Villicus | VIP Ticket ✨"),
            ephemeral=True
        )


class TicketCog(commands.Cog):
    """Ticket system with persistent ticket panels stored in guild settings.
    Panels are stored under guild_settings key `ticket_panels` as JSON mapping channel_id -> panel config.
    On startup the bot will attempt to re-attach interactive views to existing messages so buttons survive restarts.
    """
    def __init__(self, bot):
        self.bot = bot
        self.panels = {}  # channel_id -> config
        self.db = core_db.DB()
        self.bot.loop.create_task(self._init())

    async def _init(self):
        await core_db.init_db(self.db.path)
        await self.db.connect()
        await self._load_all_panels()

    async def _load_all_panels(self):
        # iterate guilds and load panels
        for guild in list(self.bot.guilds):
            try:
                raw = await self.db.get_guild_setting(guild.id, "ticket_panels")
                if not raw:
                    continue
                panels = json.loads(raw)
                for ch_id_str, cfg in panels.items():
                    ch_id = int(ch_id_str)
                    self.panels[ch_id] = cfg
                    # attempt to re-attach view to message
                    try:
                        channel = guild.get_channel(ch_id)
                        if not channel:
                            continue
                        msg_id = cfg.get('message_id')
                        if msg_id:
                            try:
                                msg = await channel.fetch_message(int(msg_id))
                                view = TicketPanelButton(cfg.get('ticket_type', 'Support'), [guild.get_role(rid) for rid in cfg.get('roles', []) if guild.get_role(rid)], cfg.get('embed_text','Open a ticket!'), cfg.get('use_thread', True))
                                try:
                                    self.bot.add_view(view, message_id=msg.id)
                                except Exception:
                                    # fallback: edit message to reattach
                                    await msg.edit(view=view)
                            except Exception:
                                continue
                    except Exception:
                        continue
            except Exception:
                continue

    async def save_panels_for_guild(self, guild_id: int):
        # save panels for a guild under key ticket_panels
        try:
            panels_for_guild = {str(k): v for k, v in self.panels.items() if self._channel_belongs_to_guild(k, guild_id)}
            await self.db.set_guild_setting(guild_id, "ticket_panels", json.dumps(panels_for_guild))
        except Exception:
            pass

    def _channel_belongs_to_guild(self, channel_id: int, guild_id: int) -> bool:
        ch = self.bot.get_channel(channel_id)
        return ch is not None and ch.guild and ch.guild.id == guild_id

    async def add_panel(self, guild_id: int, channel_id: int, config: dict):
        self.panels[int(channel_id)] = config
        await self.save_panels_for_guild(guild_id)

    async def remove_panel(self, guild_id: int, channel_id: int):
        self.panels.pop(int(channel_id), None)
        await self.save_panels_for_guild(guild_id)





# ---- FILE: villicus\bot\translate_cog.py ----

# bot/translate_cog.py
import discord
from discord.ext import commands
import aiohttp

class TranslateCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="translate", description="Translate a message or message link to a language.")
    async def translate(self, ctx, target: str, *, message: str = None):
        # If message is a Discord message link, fetch it
        if message and message.startswith("https://discord.com/channels/"):
            try:
                parts = message.split("/")
                channel_id = int(parts[-2])
                msg_id = int(parts[-1])
                channel = ctx.guild.get_channel(channel_id)
                msg_obj = await channel.fetch_message(msg_id)
                text = msg_obj.content
            except Exception:
                embed = discord.Embed(
                    title="❌ VIP Error",
                    description="Could not fetch message from link.",
                    color=discord.Color.red()
                )
                embed.set_footer(text="Villicus | VIP Experience ✨")
                await ctx.send(embed=embed)
                return
        else:
            text = message or ctx.message.content.partition(' ')[2]
        # Use LibreTranslate API (demo, replace with your own key/service for production)
        async with aiohttp.ClientSession() as session:
            async with session.post("https://libretranslate.de/translate", json={"q": text, "source": "auto", "target": target}) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    translated = data.get("translatedText", "?")
                    embed = discord.Embed(
                        title="🌐 Translation",
                        description=f"Translated: {translated}",
                        color=discord.Color.from_rgb(255, 215, 0)
                    )
                    embed.set_footer(text="Villicus | VIP Experience ✨")
                    await ctx.send(embed=embed)
                else:
                    embed = discord.Embed(
                        title="❌ VIP Error",
                        description="Translation failed.",
                        color=discord.Color.red()
                    )
                    embed.set_footer(text="Villicus | VIP Experience ✨")
                    await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(TranslateCog(bot))




# ---- FILE: villicus\bot\usage_cog.py ----

import discord
from discord.ext import commands
from core import db as core_db


class UsageCog(commands.Cog):
    """Provide usage/help for commands on demand.
    Use `/usage <command>` to show signature and description.
    """
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="usage", description="Show usage information for a command.")
    async def usage(self, ctx, *, command_name: str):
        # find command
        cmd = None
        for c in self.bot.commands:
            if c.name == command_name or c.qualified_name == command_name:
                cmd = c
                break
        if not cmd:
            # try partial match
            matches = [c for c in self.bot.commands if command_name in c.name]
            if len(matches) == 1:
                cmd = matches[0]
        if not cmd:
            await ctx.send("Command not found.")
            return
        desc = cmd.description or cmd.help or "No description provided."
        params = []
        for p in cmd.clean_params.values():
            pname = p.name
            pdef = str(p.default) if p.default is not p.empty else "required"
            params.append(f"{pname}: {pdef}")
        text = f"**/{cmd.name}** - {desc}\n\nParameters:\n"
        if params:
            text += "\n".join(f"- {x}" for x in params)
        else:
            text += "None"
        await ctx.send(text)

def setup(bot):
    bot.add_cog(UsageCog(bot))




# ---- FILE: villicus\bot\userinfo_cog.py ----

# bot/userinfo_cog.py
import discord
from discord.ext import commands

class UserInfoCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command(name="userinfo", description="Get info about a user.")
    async def userinfo(self, ctx, member: discord.Member = None):
        member = member or ctx.author
        embed = discord.Embed(title=f"User Info: {member.display_name}", color=discord.Color.blurple())
        embed.set_thumbnail(url=member.display_avatar.url)
        embed.add_field(name="ID", value=member.id)
        embed.add_field(name="Joined Discord", value=member.created_at.strftime('%Y-%m-%d'))
        embed.add_field(name="Joined Server", value=member.joined_at.strftime('%Y-%m-%d'))
        embed.add_field(name="Top Roles", value=', '.join([r.name for r in member.roles[-10:][::-1] if r != ctx.guild.default_role]))
        perms = [name.replace('_', ' ').title() for name, value in member.guild_permissions if value]
        embed.add_field(name="Permissions", value=', '.join(perms), inline=False)
        embed.set_footer(text="Villicus | VIP Experience ✨")
        await ctx.send(embed=embed)

def setup(bot):
    bot.add_cog(UserInfoCog(bot))




# ---- FILE: villicus\bot\warnings_cog.py ----

# bot/warnings_cog.py
import discord
from discord.ext import commands

class WarningsCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        # Use DB for persistent warns via ModManager/DB action logs
        from core import db as core_db
        self.db = core_db.DB()
        self.bot.loop.create_task(self._init())

    async def _init(self):
        await core_db.init_db(self.db.path)
        await self.db.connect()

    @commands.hybrid_command(name="warnings", description="Show warnings for a user.")
    async def warnings(self, ctx, member: discord.Member = None):
        member = member or ctx.author
        guild_id = ctx.guild.id
        # Query action_logs for warn entries
        rows = await self.db.fetchall("SELECT * FROM action_logs WHERE guild_id = ? AND action = 'warn' AND target = ? ORDER BY created_at DESC", [guild_id, str(member.id)])
        if not rows:
            embed = discord.Embed(
                title="⚠️ No Warnings",
                description=f"{member.mention} has no warnings.",
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | VIP Experience ✨")
            await ctx.send(embed=embed)
            return
        embed = discord.Embed(title=f"Warnings for {member.display_name}", color=discord.Color.orange())
        for i, r in enumerate(rows, 1):
            reason = r['reason'] or 'No reason provided'
            ts = r['created_at']
            embed.add_field(name=f"Warning {i}", value=f"{reason}\n(ID: {r['id']} at {ts})", inline=False)
        await ctx.send(embed=embed)

    async def add_warning(self, guild_id, user_id, reason, moderator_id: int | None = None, expires_at: int | None = None):
        await self.db.execute("INSERT INTO punishments (guild_id, user_id, action, reason, moderator_id, created_at, expires_at) VALUES (?, ?, 'warn', ?, ?, ?, ?)", [guild_id, user_id, reason, moderator_id, int(__import__('time').time()), expires_at])

def setup(bot):
    bot.add_cog(WarningsCog(bot))




# ---- FILE: villicus\bot\welcome_cog.py ----

# bot/welcome_cog.py
import discord
from discord.ext import commands
from core import db as core_db


class WelcomeCog(commands.Cog):
    """Welcome messages backed by the DB (`welcome_message`, `welcome_channel`, `welcome_ping`).
    This makes settings persistent and editable via the config commands (no in-memory only).
    """
    def __init__(self, bot):
        self.bot = bot
        self.db = core_db.DB()
        # connect asynchronously
        self.bot.loop.create_task(self._connect())

    async def _connect(self):
        await core_db.init_db(self.db.path)
        await self.db.connect()

    @commands.hybrid_command(name="setwelcome", description="Set the welcome message (use {user} placeholder).")
    @commands.has_guild_permissions(manage_guild=True)
    async def setwelcome(self, ctx, message: str = None, image_url: str = None, ping: bool = False):
        """Set or view the welcome message. If `message` omitted, shows current settings.
        When set, it defaults to the channel the command is used in.
        """
        guild_id = ctx.guild.id
        if not message:
            current = await self.db.get_guild_setting(guild_id, "welcome_message") or "(none)"
            ch = await self.db.get_guild_setting(guild_id, "welcome_channel") or "(none)"
            img = await self.db.get_guild_setting(guild_id, "welcome_image_url") or "(none)"
            pingv = await self.db.get_guild_setting(guild_id, "welcome_ping") or "0"
            await ctx.send(f"Welcome: {current}\nChannel: <#{ch}>\nImage: {img}\nPing: {bool(int(pingv))}")
            return
        await self.db.set_guild_setting(guild_id, "welcome_message", message)
        await self.db.set_guild_setting(guild_id, "welcome_channel", str(ctx.channel.id))
        await self.db.set_guild_setting(guild_id, "welcome_ping", "1" if ping else "0")
        if image_url:
            await self.db.set_guild_setting(guild_id, "welcome_image_url", image_url)
        await ctx.send(f"Welcome message saved and will be sent in {ctx.channel.mention}.")

    @commands.hybrid_command(name="setgoodbye", description="Set the goodbye message (use {user} placeholder).")
    @commands.has_guild_permissions(manage_guild=True)
    async def setgoodbye(self, ctx, message: str = None, image_url: str = None, ping: bool = False):
        guild_id = ctx.guild.id
        if not message:
            current = await self.db.get_guild_setting(guild_id, "goodbye_message") or "(none)"
            ch = await self.db.get_guild_setting(guild_id, "goodbye_channel") or "(none)"
            img = await self.db.get_guild_setting(guild_id, "goodbye_image_url") or "(none)"
            pingv = await self.db.get_guild_setting(guild_id, "goodbye_ping") or "0"
            await ctx.send(f"Goodbye: {current}\nChannel: <#{ch}>\nImage: {img}\nPing: {bool(int(pingv))}")
            return
        await self.db.set_guild_setting(guild_id, "goodbye_message", message)
        await self.db.set_guild_setting(guild_id, "goodbye_channel", str(ctx.channel.id))
        await self.db.set_guild_setting(guild_id, "goodbye_ping", "1" if ping else "0")
        if image_url:
            await self.db.set_guild_setting(guild_id, "goodbye_image_url", image_url)
        await ctx.send(f"Goodbye message saved and will be sent in {ctx.channel.mention}.")

    @commands.hybrid_command(name="setboost", description="Set the boost message (use {user} placeholder).")
    @commands.has_guild_permissions(manage_guild=True)
    async def setboost(self, ctx, message: str = None, image_url: str = None, ping: bool = False):
        guild_id = ctx.guild.id
        if not message:
            current = await self.db.get_guild_setting(guild_id, "boost_message") or "(none)"
            ch = await self.db.get_guild_setting(guild_id, "boost_channel") or "(none)"
            img = await self.db.get_guild_setting(guild_id, "boost_image_url") or "(none)"
            pingv = await self.db.get_guild_setting(guild_id, "boost_ping") or "0"
            await ctx.send(f"Boost: {current}\nChannel: <#{ch}>\nImage: {img}\nPing: {bool(int(pingv))}")
            return
        await self.db.set_guild_setting(guild_id, "boost_message", message)
        await self.db.set_guild_setting(guild_id, "boost_channel", str(ctx.channel.id))
        await self.db.set_guild_setting(guild_id, "boost_ping", "1" if ping else "0")
        if image_url:
            await self.db.set_guild_setting(guild_id, "boost_image_url", image_url)
        await ctx.send(f"Boost message saved and will be sent in {ctx.channel.mention}.")

    @commands.hybrid_command(name="welcome", description="Set the welcome message (use {user} placeholder).")
    @commands.has_guild_permissions(administrator=True)
    async def welcome(self, ctx, *, message: str = None):
        guild_id = ctx.guild.id
        if message:
            # default to current channel for welcome
            await self.db.set_guild_setting(guild_id, "welcome_message", message)
            await self.db.set_guild_setting(guild_id, "welcome_channel", str(ctx.channel.id))
            await self.db.set_guild_setting(guild_id, "welcome_ping", "0")
            embed = discord.Embed(
                title="👋 Welcome Message Set!",
                description=f"Welcome message set and will be sent in {ctx.channel.mention} (use {{user}} in the message).",
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | VIP Experience ✨")
            await ctx.send(embed=embed)
        else:
            current = await self.db.get_guild_setting(guild_id, "welcome_message") or "No welcome message set."
            ping = await self.db.get_guild_setting(guild_id, "welcome_ping") or "0"
            embed = discord.Embed(
                title="👋 Current Welcome Message",
                description=f"Current welcome: {current} | Ping: {bool(int(ping))}",
                color=discord.Color.from_rgb(255, 215, 0)
            )
            embed.set_footer(text="Villicus | VIP Experience ✨")
            await ctx.send(embed=embed)

    @commands.Cog.listener()
    async def on_member_join(self, member):
        guild_id = member.guild.id
        try:
            msg = await self.db.get_guild_setting(guild_id, "welcome_message")
            ch = await self.db.get_guild_setting(guild_id, "welcome_channel")
            ping = await self.db.get_guild_setting(guild_id, "welcome_ping")
            img = await self.db.get_guild_setting(guild_id, "welcome_image_url")
            if not msg:
                return
            # resolve channel
            channel = None
            if ch:
                try:
                    channel = member.guild.get_channel(int(ch))
                except Exception:
                    channel = None
            if not channel:
                channel = member.guild.system_channel or next((c for c in member.guild.text_channels if c.permissions_for(member.guild.me).send_messages), None)
            if not channel:
                return
            text = msg.replace("{user}", member.mention if ping and ping != "0" else member.display_name)
            if img:
                embed = discord.Embed(description=text, color=discord.Color.from_rgb(255,215,0))
                try:
                    embed.set_image(url=img)
                except Exception:
                    pass
                await channel.send(embed=embed)
            else:
                await channel.send(text)
        except Exception:
            return

    @commands.Cog.listener()
    async def on_member_remove(self, member):
        guild_id = member.guild.id
        try:
            msg = await self.db.get_guild_setting(guild_id, "goodbye_message")
            ch = await self.db.get_guild_setting(guild_id, "goodbye_channel")
            ping = await self.db.get_guild_setting(guild_id, "goodbye_ping")
            img = await self.db.get_guild_setting(guild_id, "goodbye_image_url")
            if not msg:
                return
            channel = None
            if ch:
                try:
                    channel = member.guild.get_channel(int(ch))
                except Exception:
                    channel = None
            if not channel:
                channel = member.guild.system_channel or next((c for c in member.guild.text_channels if c.permissions_for(member.guild.me).send_messages), None)
            if not channel:
                return
            text = msg.replace("{user}", member.mention if ping and ping != "0" else member.display_name)
            if img:
                embed = discord.Embed(description=text, color=discord.Color.dark_grey())
                try:
                    embed.set_image(url=img)
                except Exception:
                    pass
                await channel.send(embed=embed)
            else:
                await channel.send(text)
        except Exception:
            return

    @commands.Cog.listener()
    async def on_member_update(self, before, after):
        try:
            before_p = getattr(before, 'premium_since', None)
            after_p = getattr(after, 'premium_since', None)
            if before_p is None and after_p is not None:
                guild = after.guild
                guild_id = guild.id
                msg = await self.db.get_guild_setting(guild_id, "boost_message")
                ch = await self.db.get_guild_setting(guild_id, "boost_channel")
                ping = await self.db.get_guild_setting(guild_id, "boost_ping")
                img = await self.db.get_guild_setting(guild_id, "boost_image_url")
                if not msg:
                    return
                channel = None
                if ch:
                    try:
                        channel = guild.get_channel(int(ch))
                    except Exception:
                        channel = None
                if not channel:
                    channel = guild.system_channel or next((c for c in guild.text_channels if c.permissions_for(guild.me).send_messages), None)
                if not channel:
                    return
                text = msg.replace("{user}", after.mention if ping and ping != "0" else after.display_name)
                if img:
                    embed = discord.Embed(description=text, color=discord.Color.gold())
                    try:
                        embed.set_image(url=img)
                    except Exception:
                        pass
                    await channel.send(embed=embed)
                else:
                    await channel.send(text)
        except Exception:
            return


def setup(bot):
    bot.add_cog(WelcomeCog(bot))




# ---- FILE: villicus\bot\welcomemedia_cog.py ----

import discord
from discord.ext import commands
from PIL import Image, ImageDraw, ImageFont
import aiohttp
import io

class WelcomeMediaCog(commands.Cog):
    """Generates custom welcome/leave images for new members."""
    def __init__(self, bot):
        self.bot = bot
        self.font_path = "arial.ttf"  # Use a bundled or system font

    async def generate_image(self, member, event="welcome"):
        # Background color and text
        bg_color = (54, 57, 63) if event == "welcome" else (32, 34, 37)
        text = f"Welcome, {member.display_name}!" if event == "welcome" else f"Goodbye, {member.display_name}!"
        subtext = f"to {member.guild.name}" if event == "welcome" else f"from {member.guild.name}"
        # Create base image
        img = Image.new("RGB", (600, 200), bg_color)
        draw = ImageDraw.Draw(img)
        # Fonts
        try:
            font_big = ImageFont.truetype(self.font_path, 40)
            font_small = ImageFont.truetype(self.font_path, 24)
        except Exception:
            font_big = font_small = None
        # Draw text
        draw.text((200, 60), text, font=font_big, fill=(255, 255, 255))
        draw.text((200, 120), subtext, font=font_small, fill=(180, 180, 180))
        # User avatar
        async with aiohttp.ClientSession() as session:
            async with session.get(str(member.display_avatar.url)) as resp:
                if resp.status == 200:
                    avatar_bytes = await resp.read()
                    avatar = Image.open(io.BytesIO(avatar_bytes)).convert("RGBA").resize((128, 128))
                    img.paste(avatar, (40, 36), avatar)
        # Server icon
        if member.guild.icon:
            async with aiohttp.ClientSession() as session:
                async with session.get(str(member.guild.icon.url)) as resp:
                    if resp.status == 200:
                        icon_bytes = await resp.read()
                        icon = Image.open(io.BytesIO(icon_bytes)).convert("RGBA").resize((48, 48))
                        img.paste(icon, (540, 10), icon)
        # Save to buffer
        buf = io.BytesIO()
        img.save(buf, format="PNG")
        buf.seek(0)
        return buf

    @commands.Cog.listener()
    async def on_member_join(self, member):
        channel = discord.utils.get(member.guild.text_channels, name="welcome")
        if channel:
            buf = await self.generate_image(member, event="welcome")
            file = discord.File(buf, filename="welcome.png")
            embed = discord.Embed(title=f"Welcome {member.display_name}!", color=discord.Color.green())
            embed.set_image(url="attachment://welcome.png")
            await channel.send(embed=embed, file=file)

    @commands.Cog.listener()
    async def on_member_remove(self, member):
        channel = discord.utils.get(member.guild.text_channels, name="welcome")
        if channel:
            buf = await self.generate_image(member, event="leave")
            file = discord.File(buf, filename="goodbye.png")
            embed = discord.Embed(title=f"Goodbye {member.display_name}!", color=discord.Color.red())
            embed.set_image(url="attachment://goodbye.png")
            await channel.send(embed=embed, file=file)

def setup(bot):
    bot.add_cog(WelcomeMediaCog(bot))


